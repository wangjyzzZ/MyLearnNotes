# 模板

## 字符串

### kmp

HDU1711

```c++
int a[maxn], b[maxm], Next[maxm];
int n, m;
void pre()
{
    Next[1] = 0; int j = 0;
    for(int i = 1; i < m; i++){
        while(j && b[i+1] != b[j+1]) j = Next[j];
        if(b[i+1] == b[j+1]) j++;
        Next[i+1] = j;
    }
}
int kmp()
{
    int j = 0;
    for(int i = 0; i < n; i++){
        while(j && a[i+1] != b[j+1]) j = Next[j];
        if(a[i+1] == b[j+1]) j++;
        if(j == m){ return i+2-m; }
    }
    return -1;
}
```

### EXKMP

有两个字符串a,b,要求输出b与a的每一个后缀的最长公共前缀

```c++
int n, m;
int Next[maxn], extend[maxn]; //Next[i]表示从i开始的串和从头开始的串的最长公共前缀长度
char a[maxn], b[maxn];
void pre_EKMP()
{
    Next[1] = m;
    int j = 1;
    while(j+1 <= m && b[j] == b[j+1]) j++;
    Next[2] = j-1;
    int k = 2;
    for(int i = 3; i <= m; i++){
        int p = k+Next[k]-1;
        int L = Next[i-k+1];
        if(i+L-1 < p) Next[i] = L;
        else{
            j = max(0,p-i+1);
            while(i+j <= m && b[j+1] == b[i+j]) j++;
            Next[i] = j;
            k = i;
        }
    }
}
void EKMP()
{
    pre_EKMP();
    int j = 1;
    while(j <= n && j <= m && a[j] == b[j]) j++;
    extend[1] = j-1;
    int k = 1;
    for(int i = 2; i <= n; i++){
        int p = extend[k]+k-1;
        int L = Next[i-k+1];
        if(i+L-1 < p) extend[i] = L;
        else{
            j = max(0,p-i+1);
            while(i+j <= n && j+1 <= m && a[i+j] == b[j+1]) j++;
            extend[i] = j;
            k = i;
        }
    }
}
```

### hash

求模式串中与文本串循环同构的串有多少个

将文本串所有的循环同构的hash值计算出来，再对模式串进行计算匹配，匹配时用map会超时，改用hash表将查询时间优化至常数时间即可通过

```c++
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int maxn = 1e6 + 5;
char s[maxn];
ull p[maxn], sum[maxn];
struct Hash
{
    int mod = 9999991;
    int head[maxn], Next[maxn], sta[maxn];
    ull ver[maxn];
    int tot, top;
    void init(){
        tot = 0;
        while(top) head[sta[top--]] = 0;
    }
    void Insert(ull x){
        int h = x%mod;
        for(int i = head[h]; i; i = Next[i]){
            if(ver[i] == x) return ;
        }
        if(!head[h]) sta[++top] = h;
        Next[++tot] = head[h]; head[h] = tot; ver[tot] = x;
    }
    int query(ull x){
        int h = x%mod;
        for(int i = head[h]; i; i = Next[i]){
            if(ver[i] == x) return 1;
        }
        return 0;
    }
} h;
int main()
{
    int len, n, len1, ans;
    scanf("%s",s+1);
    len = strlen(s+1);
    p[0] = 1;
    for(int i = 1; i <= len; i++){
        p[i] = p[i-1]*131;
        sum[i] = sum[i-1]*131+(ull)(s[i]-'a'+1);
    }
    for(int i = 1; i <= len; i++){
        ull tmp = (sum[len]-sum[i-1]*p[len-i+1])*p[i-1]+sum[i-1];
        h.Insert(tmp);
    }
    scanf("%d",&n);
    while(n--){
        ans = 0;
        scanf("%s",s+1);
        len1 = strlen(s+1);
        for(int i = 1; i <= len1; i++){
            sum[i] = sum[i-1]*131+(ull)(s[i]-'a'+1);
        }
        for(int i = 1; i <= len1-len+1; i++){
            ull tmp = sum[i+len-1]-sum[i-1]*p[len];
            ans += h.query(tmp);
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

二维hash

牛客 矩阵 

找子矩阵，使得该子矩阵至少出现2次，可以二分长度，利用二维hash判断该子矩阵出现几次

```c++
#include<bits/stdc++.h>
using namespace std;
const int base1 = 131;
const int base2 = 13331;
typedef unsigned long long ull;
const int maxn = 505;
int n, m;
char s[maxn][maxn];
ull hs[maxn][maxn], p1[maxn], p2[maxn];
map<ull,int> mp;
ull gethash(int x,int y,int l)
{
    return hs[x][y]-hs[x-l][y]*p2[l]-hs[x][y-l]*p1[l]+hs[x-l][y-l]*p1[l]*p2[l];
}
bool check(int x)
{
    mp.clear();
    ull tmp;
    for(int i = x; i <= n; i++){
        for(int j = x; j <= m; j++){
            tmp = gethash(i,j,x);
            if(mp[tmp]) return true;
            mp[tmp] = 1;
        }
    }
    return false;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++){
        scanf("%s",s[i]+1);
        for(int j = 1; j <= m; j++){
            hs[i][j] = hs[i][j-1]*base1+(s[i][j]-'a'+1);
        }
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            hs[i][j] += hs[i-1][j]*base2;
        }
    }
    p1[0] = p2[0] = 1;
    for(int i = 1; i <= max(n,m); i++){
        p1[i] = p1[i-1]*base1;
        p2[i] = p2[i-1]*base2;
    }
    int l = 0, r = min(n,m), mid, ans;
    while(l <= r){
        mid = (l+r)>>1;
        if(check(mid)) ans = mid, l = mid+1;
        else r = midshu2-1;
    }
    printf("%d\n",ans);
    return 0;
}
```

树hash

h[x]表示以x为根的子树的hash值  g[x]表示以x为根的整棵树的hash值

h[x] = 1+ sum(h[v]*prime[siz[v]]);

g[x] 换根得到

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 998244353;
const int maxn = 1e5 + 5;
int tot;
int vis[maxn];
int prime[maxn], siz[maxn], h[maxn], g[maxn];
int ver[maxn], Next[maxn], head[maxn];
vector<int> v[maxn];
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
void primes(int n)
{
    int m = 0;
    for(int i = 2; i <= n; i++){
        if(!vis[i]){
            vis[i] = i; prime[++m] = i;
        }
        for(int j = 1; j <= m; j++){
            if(prime[j] > vis[i] || i*prime[j] > n) break;
            vis[i*prime[j]] = prime[j];
        }
    }
}
void dfs1(int u,int f)
{
    siz[u] = 1; h[u] = 1;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == f) continue;
        dfs1(v,u);
        siz[u] += siz[v];
        h[u] = (h[u]+(ll)h[v]*prime[siz[v]]%mod)%mod;
    }
}
void dfs2(int u,int f,int op,int n)
{
    if(u == 1) g[u] = h[u];
    else g[u] = (((g[f]-(ll)h[u]*prime[siz[u]]+mod)%mod)*prime[n-siz[u]]%mod+h[u])%mod;
    v[op].push_back(g[u]);
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == f) continue;
        dfs2(v,u,op,n);
    }
}
bool check(int x,int y)
{
    if(v[x].size() != v[y].size()) return false;
    for(auto i : v[x]){
        for(auto j : v[y]){
            if(i == j) return true;
        }
    }
    return false;
}
int main()
{
    int n, m, x;
    scanf("%d",&n);
    primes(100000);
    for(int i = 1; i <= n; i++){
        scanf("%d",&m);
        tot = 0;
        memset(head,0,sizeof(head));
        for(int j = 1; j <= m; j++){
            scanf("%d",&x);
            if(x){
                Add(x,j); Add(j,x);
            }
        }
        dfs1(1,0);
        dfs2(1,0,i,m);
        sort(v[i].begin(),v[i].end());
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= i; j++){
            if(check(i,j)){
                printf("%d\n",j);
                break;
            }
        }
    }
    return 0;
}
```

### manacher

求最长回文子串

洛谷 p3805

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 11000005;
char s[maxn], ma[maxn*2];
int mp[maxn*2]; //回文半径
void manacher(char s[],int len)
{
    int p = 0, mx = 0, id = 0;
    ma[p++] = '$'; ma[p++] = '#';
    for(int i = 1; i <= len; i++){
        ma[p++] = s[i]; ma[p++] = '#';
    }
    ma[p] = '\0';
    for(int i = 1; i <= p; i++){
        mp[i] = i < mx ? min(mp[id*2-i],mx-i) : 1;
        while(ma[i+mp[i]] == ma[i-mp[i]]) mp[i]++;
        if(i+mp[i] > mx) mx = i+mp[i], id = i;
    }
}
int main()
{
    scanf("%s",s+1);
    int len = strlen(s+1);
    manacher(s,len);
    int ans = 0;
    for(int i = 1; i <= len*2+2; i++){
        ans = max(ans,mp[i]-1);
    }
    printf("%d\n",ans);
    return 0;
}
```

### 序列自动机

```c++
int Next[maxn][30], pos[30];
void pre()
{
    memset(pos,0,sizeof(pos));
    int len = strlen(s+1);
    for(int i = len; i > -1; i--){
        for(int j = 0; j < 26; j++){
            Next[i][j] = pos[j];
        }
        if(i) pos[s[i]-'a'] = i;
    }
}
```

### AC自动机

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 5;
char s[maxn];
struct AC
{
    int tot;
    int ch[maxn][26], fail[maxn], ed[maxn];
    void init(){
        tot = 0;
        for(int i = 0; i < 26; i++) ch[0][i] = 0;
    }
    void build(char s[]){
        int now = 0, len = strlen(s+1), u;
        for(int i = 1; i <= len; i++){
            u = s[i]-'a';
            if(!ch[now][u]){
               ch[now][u] = ++tot;
               for(int j = 0; j < 26; j++) ch[tot][j] = 0;
               ed[tot] = 0;
            } 
            now = ch[now][u];
        }
        ed[now]++;
    }
    void get_fail(){
        queue<int> q;
        for(int i = 0; i < 26; i++){ 
            if(ch[0][i]){
                fail[ch[0][i]] = 0;
                q.push(ch[0][i]);
            }
        }
        while(!q.empty()){
            int u = q.front(); q.pop();
            for(int i = 0; i < 26; i++){
                if(ch[u][i]){
                    fail[ch[u][i]] = ch[fail[u]][i];
                    q.push(ch[u][i]);
                }
                else ch[u][i] = ch[fail[u]][i];
            }
        }
    }
    int query(char s[]){
        int now = 0, len = strlen(s+1), ans = 0;
        for(int i = 1; i <= len; i++){
            int u = s[i]-'a';
            now = ch[now][u];
            for(int j = now; j && ed[j] != -1; j = fail[j]){
                ans += ed[j];
                ed[j] = -1; //避免重复计数
            }
        }
        return ans;
    }
};
int main()
{
    int n;
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%s",s+1);
        build(s);
    }
    get_fail();
    scanf("%s",s+1);
    printf("%d\n",query(s));
    return 0;
}
```

### 回文树

hdu6599 I Love Palindrome String

回文树+hash

```c++
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int maxn = 3e5 + 5;
char s[maxn];
int mp[maxn], ans[maxn];
ull sum[maxn], p[maxn];
struct PAM
{
    int last, tot;
    int len[maxn], Next[maxn][26], fail[maxn], cnt[maxn];
    void init()
    {
        last = 0; tot = 1;
        len[0] = 0; len[1] = -1; fail[0] = 1;  cnt[1] = 0;
        for(int i = 0; i < 26; i++) Next[0][i] = Next[1][i] = 0;
    }
    int getfail(int x,int n)
    {
        while(s[n-len[x]-1] != s[n]) x = fail[x];
        return x;
    }
    int newnode(int x)
    {
        len[++tot] = x; cnt[tot] = 0;
        for(int i = 0; i < 26; i++) Next[tot][i] = 0;
        return tot;
    }
    void Insert(int x,int n)
    {
        int p = getfail(last,n);
        if(!Next[p][x]){
            int q = newnode(len[p]+2);
            fail[q] = Next[getfail(fail[p],n)][x];
            Next[p][x] = q;
        }
        last = Next[p][x];
        cnt[last]++;
    }
    void Count()
    {
        for(int i = tot; i; i--){
            cnt[fail[i]] += cnt[i];
        }
    }
} pam;
ull getha(int l,int r)
{
    return sum[r]-sum[l-1]*p[r-l+1];
}
bool check(int l,int r)
{
    int mid = (l+r)>>1, len = r-l+1;
    if(len == 1) return true;
    if(len&1) return getha(l,mid) == getha(mid,r);
    return getha(l,mid) == getha(mid+1,r);
}
int main()
{
    p[0] = 1;
    for(int i = 1; i < maxn; i++) p[i] = p[i-1]*131;
    while(scanf("%s",s+1) != EOF){
        pam.init();
        int len = strlen(s+1);
        for(int i = 1; i <= len; i++){
            pam.Insert(s[i]-'a',i);
            mp[pam.last] = i;
            ans[i] = 0;
        }
        pam.Count();
        for(int i = 1; i <= len; i++){
            sum[i] = sum[i-1]*131+(ull)(s[i]-'a'+1);
        }
        for(int i = 2; i <= pam.tot; i++){
            int r = mp[i], l = r-pam.len[i]+1;
            //printf("%d %d\n",l,r);
            if(check(l,r)){
                ans[pam.len[i]] += pam.cnt[i];
            }
        }
        for(int i = 1; i < len; i++) printf("%d ",ans[i]);
        printf("%d\n",ans[len]);
    }
    return 0;
}

```

P4762 [CERC2014]Virus synthesis



![1564923980459](C:\Users\84640\AppData\Roaming\Typora\typora-user-images\1564923980459.png)

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
char s[maxn];
int len[maxn], fail[maxn], Next[maxn][4], trans[maxn];
int f[maxn];
int tot, last;
queue<int> q;
void init()
{
    len[0] = 0; len[1] = -1; fail[0] = 1;
    tot = 1; last = 0; s[0] = -1;
    for(int i = 0; i < 4; i++) Next[0][i] = Next[1][i] = 0;
}
int change(char c)
{
    if(c == 'A') return 0;
    if(c == 'G') return 1;
    if(c == 'C') return 2;
    return 3;
}
int getfail(int x,int n)
{
    while(s[n-len[x]-1] != s[n]) x = fail[x];
    return x;
}
int newnode(int x)
{
    len[++tot] = x;
    for(int i = 0; i < 4; i++) Next[tot][i] = 0;
    return tot;
}
void Insert(int x,int n)
{
    int p = getfail(last,n);
    if(!Next[p][x]){
        int q = newnode(len[p]+2);
        fail[q] = Next[getfail(fail[p],n)][x];
        Next[p][x] = q;
        if(len[q] <= 2) trans[q] = fail[q];
        else{
            int tmp = trans[p];
            while(s[n-len[tmp]-1] != s[n] || (len[tmp]+2)<<1 > len[q]) tmp = fail[tmp];
            trans[q] = Next[tmp][x];
        }
    }
    last = Next[p][x];
}
int main()
{
    int t, n;
    scanf("%d",&t);
    while(t--){
        init();
        scanf("%s",s+1);
        n = strlen(s+1);
        for(int i = 1; i <= n; i++){
            int x = change(s[i]);
            Insert(x,i);
        }
        for(int i = 2; i <= tot; i++) f[i] = len[i];
        f[0] = 1;
        q.push(0);
        int ans = n;
        while(!q.empty()){
            int x = q.front(); q.pop();
            for(int i = 0; i < 4; i++){
                int y = Next[x][i];
                if(!y) continue;
                f[y] = f[x]+1;
                int tmp = trans[y];
                f[y] = min(f[y],f[tmp]+len[y]/2-len[tmp]+1);
                ans = min(ans,f[y]+n-len[y]);
                q.push(y);
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

### 后缀数组

hihocoder 后缀数组四·重复旋律4

小Hi平时的一大兴趣爱好就是演奏钢琴。我们知道一个音乐旋律被表示为长度为 N 的数构成的数列。小Hi在练习过很多曲子以后发现很多作品中的旋律有重复的部分。

我们把一段旋律称为(k,l)-重复的，如果它满足由一个长度为l的字符串重复了k次组成。 如旋律abaabaabaaba是(4,3)重复的，因为它由aba重复4次组成。

小Hi想知道一部作品中k最大的(k,l)-重复旋律。

利用循环节

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
char s[maxn];
int rk[maxn], tp[maxn], tax[maxn]; //rk[i]后缀i的排名
int height[maxn], sa[maxn], f[maxn][21]; //sa[i]排名为i的后缀位置 height[i]第i名的后缀与它前一名的后缀的最长公共前缀
int M;
void qsort(int n)
{
    for(int i = 0; i <= M; i++) tax[i] = 0;
    for(int i = 1; i <= n; i++) tax[rk[i]]++;
    for(int i = 1; i <= M; i++) tax[i] += tax[i-1];
    for(int i = n; i >= 1; i--) sa[tax[rk[tp[i]]]--] = tp[i];
}
void get_sa(int n)
{
    for(int i = 1; i <= n; i++){
        M = max(M,rk[i]=s[i]); tp[i] = i;
    }
    qsort(n);
    for(int w = 1, p = 0; p < n; M = p, w <<= 1){
        p = 0;
        for(int i = 1; i <= w; i++) tp[++p] = n-w+i;
        for(int i = 1; i <= n; i++){
            if(sa[i] > w) tp[++p] = sa[i]-w;
        }
        qsort(n);
        for(int i = 0; i <= n; i++) tp[i] = rk[i];
        rk[sa[1]] = p = 1;
        for(int i = 2; i <= n; i++){
            rk[sa[i]] = (tp[sa[i-1]] == tp[sa[i]] && tp[sa[i-1]+w] == tp[sa[i]+w]) ? p : ++p;
        }
    }
}
void get_height(int n)
{
    int k = 0;
    for(int i = 1; i <= n; i++){
        if(k) k--;
        int j = sa[rk[i]-1];
        while(j && s[i+k] == s[j+k]) k++;
        height[rk[i]] = k;
    }
}
void build(int n)
{
    for(int i = 1; i <= n; i++) f[i][0] = height[i];
    for(int j = 1; j <= bin[n]; j++){
        for(int i = 1; i+(1<<j)-1 <= n; i++){
            int t = i+(1<<(j-1));
            f[i][j] = min(f[i][j-1],f[t][j-1]);
        }
    }
}
int query(int x,int y)
{
    x = rk[x]; y = rk[y];
    if(x > y) swap(x,y);
    x++;
    int j = bin[y-x+1];
    int k = y-(1<<j)+1;
    return min(f[x][j],f[k][j]);
}
int main()
{
    scanf("%s",s+1);
    int len = strlen(s+1);
    get_sa(len);
    get_height(len);
    build(len);
    int ans = 0;
    for(int i = 1; i <= len; i++){
        for(int j = 1; j+i <= len; j += i){
            int tmp = query(j,j+i);
            ans = max(ans,tmp/i+1);
            if(j-i+tmp%i > 0){
                tmp = query(j-i+tmp%i,j+tmp%i);
                ans = max(ans,tmp/i+1);
            }
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

### 后缀自动机

```c++
struct SAM
{
    int tot, last;
    int len[maxn<<1], link[maxn<<1], Next[maxn<<1][26];
    void init(){
        len[1] = 0; link[1] = 0; tot = last = 1;
        memset(Next[1],0,sizeof(Next[1]));
    }
    int newnode(){
        tot++;
        memset(Next[tot],0,sizeof(Next[tot]));
        link[tot] = len[tot] = 0;
        return tot;
    }
    void extend(int c){
        int cur = newnode();
        len[cur] = len[last]+1;
        int p = last;
        while(p && !Next[p][c]){ Next[p][c] = cur; p = link[p]; }
        if(!p) link[cur] = 1;
        else{
            int q = Next[p][c];
            if(len[p]+1 == len[q]) link[cur] = q;
            else{
                int np = newnode();
                memcpy(Next[np],Next[q],sizeof(Next[q]));
                link[np] = link[q];
                len[np] = len[p]+1;
                while(p && Next[p][c] == q){ Next[p][c] = np; p = link[p]; }
                link[q] = link[cur] = np;
            }
        }
        last = cur;
    }
} sam;
```

最多2n个点 3n条边

 [TJOI2015]弦论

找字典序第k小的子串 op=0 不同位置的相同子串算作一个 op=1 不同位置的相同子串算作多个

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 5e5 + 5;
char s[maxn];
ll siz[maxn*2], sum[maxn*2], a[maxn*2], b[maxn*2];
struct SAM
{
    int tot, last;
    struct node{ int len, link, Next[26]; } st[maxn<<1];
    void init(){
        st[1].len = 0; st[1].link = 0; tot = last = 1;
    }
    void extend(int c){
        int cur = ++tot;
        st[cur].len = st[last].len+1;
        siz[cur]++;
        int p = last;
        while(p && !st[p].Next[c]){
            st[p].Next[c] = cur; p = st[p].link;
        }
        if(!p) st[cur].link = 1;
        else{
            int q = st[p].Next[c];
            if(st[p].len+1 == st[q].len) st[cur].link = q;
            else{
                int np = ++tot;
                st[np] = st[q];
                st[np].len = st[p].len+1;
                while(p && st[p].Next[c] == q){
                    st[p].Next[c] = np; p = st[p].link;
                }
                st[q].link = st[cur].link = np;
            }
        }
        last = cur;
    }
} sam;
int main()
{
    int op, k;
    scanf("%s%d%d",s+1,&op,&k);
    int n = strlen(s+1);
    sam.init();
    for(int i = 1; i <= n; i++) sam.extend(s[i]-'a');
    for(int i = 1; i <= sam.tot; i++) a[sam.st[i].len]++;
    for(int i = 1; i <= n; i++) a[i] += a[i-1];
    for(int i = sam.tot; i >= 1; i--) b[a[sam.st[i].len]--] = i;
    for(int i = sam.tot; i >= 1; i--){
        if(op) siz[sam.st[b[i]].link] += siz[b[i]];
        else siz[b[i]] = 1;
    }
    siz[1] = 0;
    for(int i = sam.tot; i; i--){
        int x = b[i];
        sum[x] = siz[x];
        for(int j = 0; j < 26; j++){
            if(sam.st[x].Next[j]){
                sum[x] += sum[sam.st[x].Next[j]];
            }
        }
    }
    if(k > sum[1]){
        printf("-1\n"); return 0;
    }
    int now = 1;
    while(k-siz[now] > 0){
        k -= siz[now];
        int p = 0;
        while(k > sum[sam.st[now].Next[p]]){
            k -= sum[sam.st[now].Next[p]];
            p++;
        }
        printf("%c",'a'+p);
        now = sam.st[now].Next[p];
    }
    return 0;
}
```

卡拉巴什的字符串(2020 wannafly camp day2 d)

**两个后缀的最长公共前缀就是两个后缀在parent树上的lca**

考虑一个个字母加入时动态构建后缀自动机，每当一个节点有儿子节点，那这个节点就能成为两个不同后缀的lca，就在布尔数组里标记为1。每加入一个字母都暴力维护MEX的值，均摊O(N)

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 5;
int idx, res;
char s[maxn];
int vis[maxn];
struct SAM
{
    int tot, last;
    struct node
    {
        int len, link, cnt, Next[26];
    } st[maxn<<1];
    void init()
    {
        st[1].len = st[1].link = st[1].cnt = 0;
        for(int i = 0; i < 26; i++) st[1].Next[i] = 0;
        tot = 1; last = 1;
    }
    void extend(int c)
    {
        int cur = ++tot;
        st[cur].len = st[last].len+1; st[cur].cnt = 0;
        for(int i = 0; i < 26; i++) st[cur].Next[i] = 0;
        int p = last;
        while(p && !st[p].Next[c]){
            st[p].Next[c] = cur; p = st[p].link;
        }
        if(!p) st[cur].link = 1;
        else{
            int q = st[p].Next[c];
            if(st[p].len+1 == st[q].len){
                st[cur].link = q;
            }
            else{
                int np = ++tot;
                st[np] = st[q]; st[np].cnt = 0;
                st[np].len = st[p].len+1;
                while(p && st[p].Next[c] == q){
                    st[p].Next[c] = np;
                    p = st[p].link;
                }
                st[q].link = st[cur].link = np;
            }
        }
        last = cur;
        st[st[cur].link].cnt++;
        if(st[cur].link == 1 && st[1].cnt == 2) vis[0] = idx;
        if(st[cur].link > 1 && st[st[cur].link].cnt == 1){
            vis[st[st[cur].link].len] = idx;
        }
    }

} sam;
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        idx++; res = 0;
        scanf("%s",s+1);
        int n = strlen(s+1);
        sam.init();
        for(int i = 1; i <= n; i++){
            sam.extend(s[i]-'a');
            while(vis[res] == idx) res++;
            if(i != n) printf("%d ",res);
            else printf("%d\n",res);
        }
    }
    return 0;
}
```

### 广义后缀自动机

求多个字符串的本质不同子串个数

设 |T| 为 Trie 树大小，|A|为字符集大小（可视为常数），G(T)为 Trie 树所有叶节点深度之和。

- 状态数（节点数）依旧为线性 O(2|T|) 。
- 转移函数（边数）上界为 O(|T||A|) 。
- 离线时间复杂度为 O(|T||A|+|T|)。
- 在线时间复杂度为 O(|T||A|+G(T))。

在线

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int mod = 1e9 + 7;
const int maxn = 1e6 + 5;
char s[maxn];
struct SAM
{
    int tot;
    int len[maxn<<1], link[maxn<<1], Next[maxn<<1][26];
    void init(){
        len[1] = 0; link[1] = 0; tot = 1;
        memset(Next[1],0,sizeof(Next[1]));
    }
    int newnode(){
        tot++;
        memset(Next[tot],0,sizeof(Next[tot]));
        link[tot] = len[tot] = 0;
        return tot;
    }
    int extend(int c,int last){
        if(Next[last][c]){
            int p = last, x = Next[p][c];
            if(len[p]+1 == len[x]) return x;
            else{
                int y = newnode();
                len[y] = len[p]+1;
                memcpy(Next[y],Next[x],sizeof(Next[x]));
                while(p && Next[p][c] == x){
                    Next[p][c] = y; p = link[p];
                }
                link[y] = link[x]; link[x] = y;
                return y;
            }
        }
        int cur = newnode();
        len[cur] = len[last]+1;
        int p = last;
        while(p && !Next[p][c]){ Next[p][c] = cur; p = link[p]; }
        if(!p) link[cur] = 1;
        else{
            int q = Next[p][c];
            if(len[p]+1 == len[q]) link[cur] = q;
            else{
                int np = newnode();
                memcpy(Next[np],Next[q],sizeof(Next[q]));
                link[np] = link[q];
                len[np] = len[p]+1;
                while(p && Next[p][c] == q){
                    Next[p][c] = np; p = link[p];
                }
                link[q] = link[cur] = np;
            }
        }
        return cur;
    }
} sam;
int main()
{
    int n;
    scanf("%d",&n);
    sam.init();
    for(int i = 1; i <= n; i++){
        scanf("%s",s+1);
        int len = strlen(s+1);
        int tmp = 1;
        for(int j = 1; j <= len; j++){
            tmp = sam.extend(s[j]-'a',tmp);
        }
    }
    ll ans = 0;
    for(int i = 2; i <= sam.tot; i++) ans += sam.len[i]-sam.len[sam.link[i]];
    printf("%lld\n",ans);
    return 0;
}
```

离线

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int mod = 1e9 + 7;
const int maxn = 1e6 + 5;
char s[maxn];
struct Trie
{
    int tot, c[maxn], fa[maxn], Next[maxn][26];
    //fa[x]: trie树上x的父节点
    //c[x]: trie树上x的种类
    Trie(){ tot = 1; }
    void Insert(char s[]){
        int p = 1, n = strlen(s+1);
        for(int i = 1; i <= n; i++){
            int u = s[i]-'a';
            if(!Next[p][u]) Next[p][u] = ++tot, fa[tot] = p, c[tot] = u;
            p = Next[p][u];
        }
    }
} trie;
struct SAM
{
    int tot;
    int len[maxn<<1], link[maxn<<1], Next[maxn<<1][26], pos[maxn<<1];
    //pos[x]: trie上的x节点在sam上的对应节点编号
    void init(){
        len[1] = 0; link[1] = 0; tot = 1;
        memset(Next[1],0,sizeof(Next[1]));
    }
    int newnode(){
        tot++;
        memset(Next[tot],0,sizeof(Next[tot]));
        link[tot] = len[tot] = 0;
        return tot;
    }
    int extend(int c,int last){
        int cur = newnode();
        len[cur] = len[last]+1;
        int p = last;
        while(p && !Next[p][c]){ Next[p][c] = cur; p = link[p]; }
        if(!p) link[cur] = 1;
        else{
            int q = Next[p][c];
            if(len[p]+1 == len[q]) link[cur] = q;
            else{
                int np = newnode();
                memcpy(Next[np],Next[q],sizeof(Next[q]));
                link[np] = link[q];
                len[np] = len[p]+1;
                while(p && Next[p][c] == q){ Next[p][c] = np; p = link[p]; }
                link[q] = link[cur] = np;
            }
        }
        return cur;
    }
    queue<int> Q;
    void bfs(){
        for(int i = 0; i < 26; i++){
            if(trie.Next[1][i]) Q.push(trie.Next[1][i]); //插入第一层
        }
        pos[1] = 1;//trie树上的根1在sam上的位置为根1
        while(Q.size()){
            int x = Q.front(); Q.pop();
            pos[x] = extend(trie.c[x],pos[trie.fa[x]]);
            for(int i = 0; i < 26; i++){
                if(trie.Next[x][i]) Q.push(trie.Next[x][i]);
            }
        }
    }
} sam;
int main()
{
    int n;
    scanf("%d",&n);
    sam.init();
    for(int i = 1; i <= n; i++){
        scanf("%s",s+1);
        trie.Insert(s);
    }
    sam.bfs();
    ll ans = 0;
    for(int i = 2; i <= sam.tot; i++) ans += sam.len[i]-sam.len[sam.link[i]];
    printf("%lld\n",ans);
    return 0;
}
```

## 数据结构

### RMQ

洛谷P3865 求区间最大值

#### 一维st表

```c++
int f[maxn][21], bin[maxn];
bin[0] = -1;
for(int i = 1; i <= n; i++) bin[i] = bin[i>>1]+1;
void build(int n)
{
    for(int i = 1; i <= n; i++) f[i][0] = a[i];
    for(int j = 1; j <= bin[n]; j++){
        for(int i = 1; i+(1<<j)-1 <= n; i++){
            int t = i+(1<<(j-1));
            f[i][j] = min(f[i][j-1],f[t][j-1]);
        }
    }
}
int query(int x,int y)
{
    int j = bin[y-x+1];
    int k = y-(1<<j)+1;
    return min(f[x][j],f[k][j]);
}
```

洛谷 P2048 [NOI2010]超级钢琴

利用st表统计区间最大值的位置，利用优先队列每回去除最大值后，在更新他两边的最大值进入队列，就可以保证求出的是前k大的字段和

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 5e5 + 5;
int sum[maxn], mx[maxn][21], id[maxn][21];
struct node
{
    int st, l, r, ed;
    bool operator < (const node &rhs) const{
        return sum[ed]-sum[st-1] < sum[rhs.ed]-sum[rhs.st-1];
    }
};
priority_queue<node> q;
void build(int n)
{
    int k = (int)log2(n*1.0);
    for(int j = 1; j <= k; j++){
        for(int i = 1; i+(1<<j)-1 <= n; i++){
            int t = i+(1<<(j-1));
            mx[i][j] = max(mx[i][j-1],mx[t][j-1]);
            if(mx[i][j-1] > mx[t][j-1]){
                id[i][j] = id[i][j-1];
            }
            else{
                id[i][j] = id[t][j-1];
            }
        }
    }
}
int query(int l,int r)
{
    int j = (int)log2((r-l+1)*1.0);
    int k = r-(1<<j)+1;
    if(mx[l][j] > mx[k][j]) return id[l][j];
    return id[k][j];
}
int main()
{
    int n, m, l, r, tmp;
    scanf("%d%d%d%d",&n,&m,&l,&r);
    for(int i = 1; i <= n; i++){
        scanf("%d",&sum[i]);
        sum[i] += sum[i-1];
        mx[i][0] = sum[i];
        id[i][0] = i;
    }
    build(n);
    for(int i = 1; i <= n; i++){
        if(i+l-1 > n) break;
        if(i+r-1 > n){
            tmp = query(i+l-1,n);
            q.push((node){i,i+l-1,n,tmp});
        }
        else{
            tmp = query(i+l-1,i+r-1);
            q.push((node){i,i+l-1,i+r-1,tmp});
        }
    }
    ll ans = 0;
    node p;
    while(m--){
        p = q.top(); q.pop();
        ans += sum[p.ed]-sum[p.st-1];
        if(p.l != p.ed){
            tmp = query(p.l,p.ed-1);
            q.push((node){p.st,p.l,p.ed-1,tmp});
        }
        if(p.r != p.ed){
            tmp = query(p.ed+1,p.r);
            q.push((node){p.st,p.ed+1,p.r,tmp});
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```

#### 二维st表

```c++
void build()
{
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            mx[i][j][0][0] = min(min(f1[i][j],f2[i][j]),min(f3[i][j],f4[i][j]));
        }
    }
    for(int p = 0; p <= 9; p++){
        for(int q = 0; q <= 9; q++){
            if(p != 0 || q != 0){
                for(int i = 1; i+(1<<p)-1 <= n; i++){
                    for(int j = 1; j+(1<<q)-1 <= m; j++){
                        if(!p) mx[i][j][p][q] = max(mx[i][j][p][q-1],mx[i][j+(1<<(q-1))][p][q-1]);
                        else mx[i][j][p][q] = max(mx[i][j][p-1][q],mx[i+(1<<(p-1))][j][p-1][q]);
                    }
                }
            }
        }
    }
}
int query(int r1,int c1,int r2,int c2)
{
    int k1 = log(r2-r1+1)/log(2);
    int k2 = log(c2-c1+1)/log(2);
    int tmp1 = max(mx[r1][c1][k1][k2],mx[r2-(1<<k1)+1][c1][k1][k2]);
    int tmp2 = max(mx[r1][c2-(1<<k2)+1][k1][k2],mx[r2-(1<<k1)+1][c2-(1<<k2)+1][k1][k2]);
    return max(tmp1,tmp2);
}
```

### 笛卡尔树

![](E:\tools\typora\image-20201017093833003.png)

```c++
每个点（key，val），构建时保证key递增
int a[maxn];
int sta[maxn], ls[maxn], rs[maxn], fa[maxn];
void build(int n)
{
    int top = 0;
    for(int i = 1; i <= n; i++){
        int flag = 0;
        while(top && a[sta[top]] > a[i]) top--, flag = 1;
        if(top) fa[i] = sta[top], rs[sta[top]] = i;
        if(flag) ls[i] = sta[top+1], fa[ls[i]] = i;
        sta[++top] = i;
    }
}
```

### 倍增求lca

bzoj3631

树上差分  u,v各+1，lca(u,v)--, lca的fa--

```c++
void dfs1(int u,int ff)
{
    fa[u][0] = ff;
    dep[u] = dep[ff]+1;
    for(int i = 0; i <= 19; i++) fa[u][i+1] = fa[fa[u][i]][i];
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff) continue;
        dfs1(v,u);
    }
}
int lca(int x,int y)
{
    if(dep[x] < dep[y]) swap(x,y);
    for(int i = 20; i >= 0; i--){
        if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];
        if(x == y) return x;
    }
    for(int i = 20; i >= 0; i--){
        if(fa[x][i] != fa[y][i]){
            x = fa[x][i]; y = fa[y][i];
        }
    }
    return fa[x][0];
}
```

### 树分治

#### 点分治

POJ1741 求树上距离小于k的点对

```c++
int ver[maxn*2], edge[maxn*2], Next[maxn*2], head[maxn];
int del[maxn], siz[maxn], dis[maxn];
int tot, n, k, root, num, M, ans, cnt;
void getroot(int u,int f)  //求树的重心
{
    siz[u] = 1;
    int max_part = 0;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == f || del[v]) continue;
        getroot(v,u);
        siz[u] += siz[v];
        max_part = max(max_part,siz[v]);
    }
    max_part = max(max_part,num-siz[u]);
    if(max_part < M){ M = max_part; root = u; }
}
void getdis(int u,int f,int d)
{
    dis[++cnt] = d;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == f || del[v]) continue;
        getdis(v,u,d+edge[i]);
    }
}
int calc(int u,int d)
{
    cnt = 0;
    getdis(u,0,d);
    sort(dis+1,dis+cnt+1);
    int l = 1, r = cnt, res = 0;
    while(l < r){
        if(dis[l]+dis[r] <= k) res += r-l, l++;
        else r--;
    }
    return res;
}
void solve(int u)
{
    ans += calc(u,0);
    del[u] = 1;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(del[v]) continue;
        ans -= calc(v,edge[i]);
        M = 0x7fffffff; num = siz[v];
        getroot(v,u);
        solve(root);
    }
}
```

#### 动态点分治(点分树)

P6329 【模板】点分树 | 震波

给定一棵树，要求支持两种操作：

操作	描述
(0,x,k)	求所有和节点x距离不超过K的节点权值和
(1,x,y)	将节点x的权值修改为y

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
int tot, M, num, root, n;
int top[maxn], Siz[maxn];
int siz[maxn], dis[maxn], fa[maxn], son[maxn];
int a[maxn], dep[maxn], del[maxn], Fa[maxn];
int ver[maxn*2], edge[maxn*2], Next[maxn*2], head[maxn];
void Add(int x,int y,int z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
void dfs1(int u,int ff) //树剖维护lca
{
    Siz[u] = 1; fa[u] = ff;
    dep[u] = dep[ff]+1;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff) continue;
        dis[v] = dis[u]+edge[i];
        dfs1(v,u);
        Siz[u] += Siz[v];
        if(Siz[v] > Siz[son[u]]) son[u] = v;
    }
}
void dfs2(int u,int ff)
{
    if(son[u]){
        top[son[u]] = top[u];
        dfs2(son[u],u);
    }
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(top[v]) continue;
        top[v] = v;
        dfs2(v,u);
    }
}
int lca(int x,int y)
{
    int fx = top[x], fy = top[y];
    while(fx != fy){
        if(dep[fx] < dep[fy]) swap(x,y), swap(fx,fy);
        x = fa[fx]; fx = top[x];
    }
    if(dep[x] > dep[y]) swap(x,y);
    return x;
}
int Dis(int u,int v)
{
    return dis[u]+dis[v]-2*dis[lca(u,v)];
}
void getroot(int u,int ff) //找重心
{
    siz[u] = 1;
    int max_part = 0;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff || del[v]) continue;
        getroot(v,u);
        siz[u] += siz[v];
        max_part = max(max_part,siz[v]);
    }
    max_part = max(max_part,num-siz[u]);
    if(max_part < M){ M = max_part; root = u; }
}
void Dfs(int u,int ff)
{
    del[u] = 1; Fa[u] = ff; //构建重心之间分关系，形成点分树
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(del[v]) continue;
        M = n; num = siz[v];
        getroot(v,u);
        Dfs(root,u);
    }
}
struct node //两颗线段树维护信息
{
    int l, r, sum;
} tree[maxn*200];
int totx;
int T[maxn*2];
void update(int &rt,int num,int l,int r,int x)
{
    if(!rt) rt = ++totx;
    tree[rt].sum += x;
    if(l == r) return ;
    int mid = (l+r)>>1;
    if(mid >= num) update(tree[rt].l,num,l,mid,x);
    else update(tree[rt].r,num,mid+1,r,x);
}
int query(int rt,int L,int R,int l,int r)
{
    if(!rt) return 0;
    if(l >= L && r <= R) return tree[rt].sum;
    int mid = (l+r)>>1, res = 0;
    if(mid >= L) res += query(tree[rt].l,L,R,l,mid);
    if(mid < R) res += query(tree[rt].r,L,R,mid+1,r);
    return res;
}
void pupdate(int u,int x) //树高log，暴力跳fa即可
{
    update(T[u],0,0,n,x);
    for(int i = u; Fa[i]; i = Fa[i]){
        int d = Dis(u,Fa[i]);
        update(T[Fa[i]],d,0,n,x);
        update(T[i+n],d,0,n,x);
    }
}
int pquery(int u,int x)
{
    int res = query(T[u],0,x,0,n);
    for(int i = u; Fa[i]; i = Fa[i]){
        int d = Dis(u,Fa[i]);
        if(d > x) continue;
        res += query(T[Fa[i]],0,x-d,0,n);
        res -= query(T[i+n],0,x-d,0,n);
    }
    return res;
}
int main()
{
    int m, x, y, op;
    read(n); read(m);
    for(int i = 1; i <= n; i++) read(a[i]);
    for(int i = 1; i < n; i++){
        read(x); read(y);
        Add(x,y,1); Add(y,x,1);
    }
    dfs1(1,0);
    top[1] = 1;
    dfs2(1,0);
    M = 1e9; num = n;
    getroot(1,0);
    Dfs(root,0);
    for(int i = 1; i <= n; i++) pupdate(i,a[i]);
    int lastans = 0;
    while(m--){
        read(op); read(x); read(y);
        if(op){
            x ^= lastans; y ^= lastans;
            pupdate(x,y-a[x]);
            a[x] = y;
        }
        else{
            x ^= lastans; y ^= lastans;
            lastans = pquery(x,y);
            printf("%d\n",lastans);
        }
    }
    return 0;
}
```

### 树状数组

牛客  华华开始学信息学

频繁跟新时，可设立一个阈值

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
const int s = 500;
long long a[maxn], extra[s];
int n, m;
int lowbit(int x){return x&(-x);}
void update(int k,int x)
{
    for(int i = k; i <= n; i += lowbit(i)) a[i] += x;
}
long long getnum(int x)
{
    long long ans = 0;
    for(int i = x; i; i -= lowbit(i)) ans += a[i];
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    int op, x, y;
    for(int i = 1; i <= m; i++){
        scanf("%d%d%d",&op,&x,&y);
        if(op == 1){
            if(x < s) extra[x] += y;
            else{
                for(int j = x; j <= n; j += x) update(j,y);
            }
        }
        else{
            long long ans = getnum(y)-getnum(x-1);
            for(int j = 1; j < s; j++){
                ans += extra[j]*(y/j-(x-1)/j);
            }
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```

#### 求最长上升子序列O(nlogn)

利用树状数组求前缀的性质，计算前缀最大，不断累加更新

```c++
#include<cstdio>
#include<algorithm>
using namespace std;
int a[1005], c[10005];
int lowbit(int x){ return x&(-x); }
void update(int k,int x)
{
    for(int i = k; i <= 10001; i += lowbit(i)) c[i] = max(c[i],x);
}
int query(int k)
{
    int res = 0;
    for(int i = k; i; i -= lowbit(i)) res = max(res,c[i]);
    return res;
}
int main()
{
    int n, tmp, ans = 0;
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%d",&a[i]);
        a[i]++;
    }
    for(int i = 1; i <= n; i++){
        tmp = query(a[i]-1)+1;
        ans = max(ans,tmp);
        update(a[i],tmp);
    }
    printf("%d\n",ans);
    return 0;
}
```

### 单调栈

牛客 区间

求所有区间中max(ai-aj)的和

所有区间最大值减去最小值的值和

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
int a[maxn], lmx[maxn], rmx[maxn];
int lmn[maxn], rmn[maxn], sta[maxn];
int main()
{
    int t, n;
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        for(int i = 1; i <= n; i++){
            scanf("%d",&a[i]);
        }
        int top = 0, cur;
        for(int i = 1; i <= n; i++){
            while(top){
                cur = sta[top];
                if(a[cur] < a[i]) break; //不唯一时
                --top;
            }
            if(!top) lmn[i] = 1;
            else lmn[i] = sta[top]+1;
            sta[++top] = i;
        }
        top = 0;
        for(int i = n; i >= 1; i--){
            while(top){
                cur = sta[top];
                if(a[cur] <= a[i]) break; //唯一时
                --top;
            }
            if(!top) rmn[i] = n;
            else rmn[i] = sta[top]-1;
            sta[++top] = i;
        }
        top = 0;
        for(int i = 1; i <= n; i++){
            while(top){
                cur = sta[top];
                if(a[cur] > a[i]) break;
                --top;
            }
            if(!top) lmx[i] = 1;
            else lmx[i] = sta[top]+1;
            sta[++top] = i;
        }
        top = 0;
        for(int i = n; i >= 1; i--){
            while(top){
                cur = sta[top];
                if(a[cur] >= a[i]) break;
                --top;
            }
            if(!top) rmx[i] = n;
            else rmx[i] = sta[top]-1;
            sta[++top] = i;
        }
        ll mx = 0, mn = 0;
        for(int i = 1; i <= n; i++){
            mx += (ll)a[i]*(rmx[i]-lmx[i]+(ll)(i-lmx[i])*(rmx[i]-i));
            mn += (ll)a[i]*(rmn[i]-lmn[i]+(ll)(i-lmn[i])*(rmn[i]-i));
        }
        printf("%lld\n",mx-mn);
    }
    return 0;
}

```

洛谷 p1169 棋盘制作

01矩阵找其中最大的正方形和最大的矩形面积（矩阵要求01相间）

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2005;
int c[maxn], w[maxn];
int h[maxn][maxn], sta[maxn];
int a[maxn][maxn], r[maxn][maxn];
int main()
{
    int n, m;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            scanf("%d",&a[i][j]);
            if(i == 1) h[i][j] = 1;
            else if(a[i-1][j] != a[i][j]) h[i][j] = h[i-1][j]+1;
            else h[i][j] = 1;
        }
    }
    for(int i = 1; i <= n; i++){
        for(int j = m; j >= 1; j--){
            if(j == m) r[i][j] = 1;
            else if(a[i][j] != a[i][j+1]) r[i][j] = r[i][j+1]+1;
            else r[i][j] = 1;
        }
    }
    int ans1 = 0, ans2 = 0, p;
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            int cnt = 0;
            for(int k = j; k <= j+r[i][j]-1; k++){
                c[++cnt] = h[i][k];
            }
            c[++cnt] = p = 0;
            for(int k = 1; k <= cnt; k++){
                if(c[k] > sta[p]){
                    sta[++p] = c[k]; w[p] = 1;
                }
                else{
                    int width = 0;
                    while(c[k] < sta[p]){
                        width += w[p];
                        if(width == sta[p]) ans1 = max(ans1,width*sta[p]);
                        else ans2 = max(ans2,width*sta[p]);
                        p--;
                    }
                    sta[++p] = c[k]; w[p] = width+1;
                }
            }
            j = j+r[i][j]-1;
        }
    }
    printf("%d\n%d\n",ans1,ans2);
    return 0;
}

```

### 单调队列

老板需要你帮忙浇花。给出N滴水的坐标，y表示水滴的高度，x表示它下落到x轴的位置。

每滴水以每秒1个单位长度的速度下落。你需要把花盆放在x轴上的某个位置，使得从被花盆接着的第1滴水开始，到被花盆接着的最后1滴水结束，之间的时间差至少为D。

我们认为，只要水滴落到x轴上，与花盆的边沿对齐，就认为被接住。给出N滴水的坐标和D的大小，请算出最小的花盆的宽度W。

P2698 [USACO12MAR]花盆Flowerpot

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int q1[maxn], q2[maxn];
struct node{ int x, y; } q[maxn];
bool cmp(node q1,node q2){ return q1.x < q2.x; }
int main()
{
    int n, m;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++){
        scanf("%d%d",&q[i].x,&q[i].y);
    }
    sort(q+1,q+n+1,cmp);
    int h1 = 1, h2 = 1, t1 = 0, t2 = 0, r = 0;
    int ans = 0x3f3f3f3f;
    for(int i = 1; i <= n; i++){
        while(h1 <= t1 && q1[h1] < i) ++h1; //滑动窗口
        while(h2 <= t2 && q2[h2] < i) ++h2;
        while(q[q1[h1]].y-q[q2[h2]].y < m && r < n){
            r++;
            while(h1 <= t1 && q[r].y >= q[q1[t1]].y) t1--; //单调队列
            while(h2 <= t2 && q[r].y <= q[q2[t2]].y) t2--;
            q1[++t1] = r; q2[++t2] = r;
        }
        if(q[q1[h1]].y-q[q2[h2]].y >= m) ans = min(ans,q[r].x-q[i].x);
    }
    if(ans == 0x3f3f3f3f) printf("-1\n");
    else printf("%d\n",ans);
    return 0;
}

```

P2219 [HAOI2007]修筑绿化带

为了增添公园的景致，现在需要在公园中修筑一个花坛，同时在画坛四周修建一片绿化带，让花坛被绿化带围起来。

如果把公园看成一个M*N的矩形，那么花坛可以看成一个C*D的矩形，绿化带和花坛一起可以看成一个A*B的矩形。

如果将花园中的每一块土地的“肥沃度”定义为该块土地上每一个小块肥沃度之和，那么，

绿化带的肥沃度=A*B块的肥沃度-C*D块的肥沃度

为了使得绿化带的生长得旺盛，我们希望绿化带的肥沃度最大。

单调队列先处理出行的信息用rmn[i] [j] 表示第i行j-b+1+d-j的最小值

再在rmn上对于每列进行处理，就可以得到一个子矩阵的最小值

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1005;
int s[maxn][maxn], s1[maxn][maxn], s2[maxn][maxn];
int rmn[maxn][maxn], mn[maxn][maxn];
deque<int> q;
int main()
{
    int n, m, a, b, c, d;
    scanf("%d%d%d%d%d%d",&n,&m,&a,&b,&c,&d);
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= m; j++){
            scanf("%d",&s[i][j]);
            s[i][j] += s[i-1][j]+s[i][j-1]-s[i-1][j-1];
        }
    }
    for(int i = a; i <= n; i++){
        for(int j = b; j <= m; j++){
            s1[i][j] = s[i][j]-s[i-a][j]-s[i][j-b]+s[i-a][j-b];
        }
    }
    for(int i = c+1; i < n; i++){
        for(int j = d+1; j < m; j++){
            s2[i][j] = s[i][j]-s[i-c][j]-s[i][j-d]+s[i-c][j-d];
        }
    }
    for(int i = c+1; i < n; i++){
        while(!q.empty()) q.pop_back();
        for(int j = d+1; j < m; j++){
            while(!q.empty() && s2[i][j] <= s2[i][q.back()]) q.pop_back();
            q.push_back(j);
            while(q.front() < j-b+2+d) q.pop_front();
            if(j >= b-1) rmn[i][j+1] = s2[i][q.front()];
        }
    }
    for(int j = b; j <= m; j++){
        while(!q.empty()) q.pop_back();
        for(int i = c+1; i < n; i++){
            while(!q.empty() && rmn[i][j] <= rmn[q.back()][j]) q.pop_back();
            q.push_back(i);
            while(q.front() < i-a+2+c) q.pop_front();
            if(i >= a-1) mn[i+1][j] = rmn[q.front()][j];
        }
    }
    int ans = 0;
    for(int i = a; i <= n; i++){
        for(int j = b; j <= m; j++){
            ans = max(ans,s1[i][j]-mn[i][j]);
        }
    }
    printf("%d\n",ans);
    return 0;
}
```

Planting Trees 2019牛客多校第三场

找出最大的子矩阵最大值与最小值之差小于等于m

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 505;
const int inf = 0x3f3f3f3f;
int a[maxn][maxn], mx[maxn], mn[maxn];
int q1[maxn], q2[maxn];
inline int read()
{
    int s = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ (s *= 10) += ch-'0'; ch = getchar(); }
    return s*f;
}
int main()
{
    int t, n, m;
    t = read();
    while(t--){
        n = read(); m = read();
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= n; j++){
                a[i][j] = read();
            }
        }
        int h1, h2, t1, t2, p, ans = 0;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= n; j++){ mx[j] = -inf; mn[j] = inf; }
            for(int j = i; j <= n; j++){
                for(int k = 1; k <= n; k++){
                    mx[k] = max(mx[k],a[j][k]);
                    mn[k] = min(mn[k],a[j][k]);
                }
                h1 = h2 = 1; t1 = t2 = p = 0;
                for(int k = 1; k <= n; k++){
                    while(h1 <= t1 && mx[k] >= mx[q1[t1]]) t1--;
                    while(h2 <= t2 && mn[k] <= mn[q2[t2]]) t2--;
                    q1[++t1] = k; q2[++t2] = k;
                    while(h1 <= t1 && h2 <= t2 && mx[q1[h1]]-mn[q2[h2]] > m){
                        p++;
                        while(h1 <= t1 && q1[h1] <= p) h1++;
                        while(h2 <= t2 && q2[h2] <= p) h2++;
                    }
                    ans = max(ans,(j-i+1)*(k-p));
                }
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

### 树套树

查询二维区间最大值

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2005*2;
ll a[2005][2005];
int n;
ll tree[maxn][maxn];
template<class T>inline void read(T &res)
{
    char c;T flag=1;
    while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;res=c-'0';
    while((c=getchar())>='0'&&c<='9')res=res*10+c-'0';res*=flag;
}
int id(int l,int r){ return l + r | l != r;  } //将线段树空间复杂度由4n降为2n
void build(ll* tree,int x,int l,int r)
{
    if(l == r){
        tree[id(l,r)] = a[x][l];
        return ;
    }
    int mid = (l+r)>>1;
    build(tree,x,l,mid);
    build(tree,x,mid+1,r);
    tree[id(l,r)] = max(tree[id(l,mid)],tree[id(mid+1,r)]);
}
void Merge(ll* tree,ll* ls,ll* rs,int l,int r)
{
    if(l == r){
        tree[id(l,r)] = max(ls[id(l,r)],rs[id(l,r)]);
        return ;
    }
    int mid = (l+r)>>1;
    Merge(tree,ls,rs,l,mid);
    Merge(tree,ls,rs,mid+1,r);
    tree[id(l,r)] = max(ls[id(l,r)],rs[id(l,r)]);
}
void build(int l,int r)
{
    if(l == r){
        build(tree[id(l,r)],l,1,n);
        return ;
    }
    int mid = (l+r)>>1;
    build(l,mid); build(mid+1,r);
    Merge(tree[id(l,r)],tree[id(l,mid)],tree[id(mid+1,r)],1,n);
}
ll query(ll* tree,int l,int r,int y1,int y2)
{
    if(l >= y1 && r <= y2){
        return tree[id(l,r)];
    }
    int mid = (l+r)>>1;
    ll res = 0;
    if(mid >= y1) res = max(res,query(tree,l,mid,y1,y2));
    if(mid < y2) res = max(res,query(tree,mid+1,r,y1,y2));
    return res;
}
ll query(int l,int r,int x1,int x2,int y1,int y2)
{
    if(l >= x1 && r <= x2){
        return query(tree[id(l,r)],1,n,y1,y2);
    }
    int mid = (l+r)>>1;
    ll res = 0;
    if(mid >= x1) res = max(res,query(l,mid,x1,x2,y1,y2));
    if(mid < x2) res = max(res,query(mid+1,r,x1,x2,y1,y2));
    return res;
}
int main()
{
    int m1, m2;
    read(n); read(m1); read(m2);
    int x1, y1, x2, y2, w;
    for(int i = 1; i <= m1; i++){
        read(x1); read(y1); read(x2); read(y2); read(w);
        a[x1][y1] += w;
        a[x1][y2+1] -= w;
        a[x2+1][y1] -= w;
        a[x2+1][y2+1] += w;
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            a[i][j] += a[i-1][j];
        }
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            a[i][j] += a[i][j-1];
        }
    }
    build(1,n);
    for(int i = 1; i <= m2; i++){
        read(x1); read(y1); read(x2); read(y2);
        printf("%lld\n",query(1,n,x1,x2,y1,y2));
    }
    return 0;
}
```

### 线段树

维护区间最大最小值

cf1263E 

对于括号匹配 区间最小值小于0则不合法 染几种色根据区间最大值

```c++
struct node
{
    int l, r, mx, mn, lazy;
} tree[maxn*4];
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r;
    tree[k].mx = tree[k].mn = tree[k].lazy = 0;
    if(l == r) return ;
    int mid = (l+r)>>1;
    build(k<<1,l,mid); build(k<<1|1,mid+1,r);
}
void pushup(int k)
{
    tree[k].mx = max(tree[k<<1].mx,tree[k<<1|1].mx);
    tree[k].mn = min(tree[k<<1].mn,tree[k<<1|1].mn);
}
void pushdown(int k)
{
    int ls = k<<1, rs = k<<1|1;
    if(!tree[k].lazy) return ;
    tree[ls].mn += tree[k].lazy;
    tree[ls].mx += tree[k].lazy;
    tree[ls].lazy += tree[k].lazy;
    tree[rs].mn += tree[k].lazy;
    tree[rs].mx += tree[k].lazy;
    tree[rs].lazy += tree[k].lazy;
    tree[k].lazy = 0;
}
void update(int k,int l,int r,int x)
{
    if(tree[k].l >= l && tree[k].r <= r){
        tree[k].mx += x;
        tree[k].mn += x;
        tree[k].lazy += x;
        return ;
    }
    pushdown(k);
    int mid = (tree[k].l+tree[k].r)>>1;
    if(mid >= l) update(k<<1,l,r,x);
    if(mid < r) update(k<<1|1,l,r,x);
    pushup(k);
}
```

cf817F mex queries

三种操作

1 是区间填满 2 是区间清空 3 翻转区间，去除存在，添加不存     每次输出最小的不存在的值

离散化后只需要维护离散区间和即可 此时所有的区间粒度最小

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 4e5 + 5;
ll a[maxn];
struct qnode{ int op; ll l, r; } q[maxn];
struct node
{
    int l, r; ll sum, lazy;
} tree[maxn*4];
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r;
    tree[k].sum = 0; tree[k].lazy = -1;
    if(l == r) return ;
    int mid = (l+r)>>1;
    build(k<<1,l,mid); build(k<<1|1,mid+1,r);
}
void pushdown(int k)
{
    if(tree[k].lazy == -1) return ;
    int ls = k<<1, rs = k<<1|1, op = tree[k].lazy;
    if(op < 2){
        tree[ls].sum = op*(tree[ls].r-tree[ls].l+1);
        tree[rs].sum = op*(tree[rs].r-tree[rs].l+1);
        tree[ls].lazy = tree[rs].lazy = op;
    }
    else{
        tree[ls].sum = tree[ls].r-tree[ls].l+1-tree[ls].sum;
        tree[rs].sum = tree[rs].r-tree[rs].l+1-tree[rs].sum;
        tree[ls].lazy = 1-tree[ls].lazy;
        tree[rs].lazy = 1-tree[rs].lazy;
    }
    tree[k].lazy = -1;
}
void pushup(int k)
{
    tree[k].sum = tree[k<<1].sum+tree[k<<1|1].sum;
}
void update(int k,int l,int r,int op)
{
    if(tree[k].l >= l && tree[k].r <= r){
        if(op == 1) tree[k].sum = tree[k].r-tree[k].l+1, tree[k].lazy = 1;
        else if(op == 2) tree[k].sum = 0, tree[k].lazy = 0;
        else tree[k].sum = tree[k].r-tree[k].l+1-tree[k].sum, tree[k].lazy = 1-tree[k].lazy;
        return ;
    }
    pushdown(k);
    int mid = (tree[k].l+tree[k].r)>>1;
    if(mid >= l) update(k<<1,l,r,op);
    if(mid < r) update(k<<1|1,l,r,op);
    pushup(k);
}
int query(int k)
{
    if(tree[k].l == tree[k].r){
        return tree[k].l;
    }
    pushdown(k);
    int ls = k<<1;
    if(tree[ls].sum < tree[ls].r-tree[ls].l+1) return query(k<<1);
    return query(k<<1|1);
}
int main()
{
    int n;
    scanf("%d",&n);
    int cnt = 0;
    for(int i = 1; i <= n; i++){
        scanf("%d%lld%lld",&q[i].op,&q[i].l,&q[i].r);
        a[++cnt] = q[i].l; a[++cnt] = q[i].r+1;
        a[++cnt] = q[i].r;
    }
    a[++cnt] = 1;
    sort(a+1,a+cnt+1);
    cnt = unique(a+1,a+cnt+1)-a-1;
    build(1,1,cnt);
    for(int i = 1; i <= n; i++){
        int l = lower_bound(a+1,a+cnt+1,q[i].l)-a;
        int r = lower_bound(a+1,a+cnt+1,q[i].r)-a;
        update(1,l,r,q[i].op);
        printf("%lld\n",a[query(1)]);
    }
    return 0;
}
```

#### 权值线段树

BZOJ4627 

```c++
int tot = 1, root = 1;
struct node{ int l, r, sum; } tree[maxn*20];
void init()
{
    tree[1].l = tree[1].r = tree[1].sum = 0;
}
void update(int &rt,ll num,ll l,ll r)
{
    if(!rt){
        rt = ++tot;
        tree[rt].l = tree[rt].r = tree[rt].sum = 0;
    }
    tree[rt].sum++;
    if(l == r) return ;
    ll mid = (l+r)>>1;
    if(num <= mid) update(tree[rt].l,num,l,mid);
    else update(tree[rt].r,num,mid+1,r);
}
void query(int rt,ll L,ll R,ll l,ll r)
{
    if(l >= L && r <= R){
        ans += tree[rt].sum;
        return ;
    }
    ll mid = (l+r)>>1;
    if(L <= mid && tree[rt].l) query(tree[rt].l,L,R,l,mid);
    if(R > mid && tree[rt].r) query(tree[rt].r,L,R,mid+1,r);
}
```

#### 线段树合并

P3224 [HNOI2012]永无乡

永无乡包含 n 座岛，编号从 1 到 n ，每座岛都有自己的独一无二的重要度，按照重要度可以将这 n座岛排名，名次用 1 到 n 来表示。某些岛之间由巨大的桥连接，通过桥可以从一个岛到达另一个岛。如果从岛 a 出发经过若干座（含 0 座）桥可以 到达岛 b ，则称岛 a 和岛 b 是连通的。

现在有两种操作：

B x y 表示在岛 x 与岛 y 之间修建一座新桥。

Q x k 表示询问当前与岛 x 连通的所有岛中第 k 重要的是哪座岛，即所有与岛 x 连通的岛中重要度排名第 k 小的岛是哪座，请你输出那个岛的编号。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int a[maxn], id[maxn], prt[maxn], root[maxn];
char s[5];
int tot;
struct node{ int l, r, sum; } tree[maxn*20];
inline int read()
{
    int s = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ (s *= 10) += ch-'0'; ch = getchar(); }
    return s*f;
}
int getpa(int x){ return prt[x] == x ? x : prt[x] = getpa(prt[x]); }
void update(int &rt,int num,int l,int r)
{
    if(!rt){
        rt = ++tot;
        tree[rt].l = tree[rt].r = tree[rt].sum = 0;
    }
    tree[rt].sum++;
    if(l == r) return ;
    int mid = (l+r)>>1;
    if(mid >= num) update(tree[rt].l,num,l,mid);
    else update(tree[rt].r,num,mid+1,r);
}
int query(int rt,int num,int l,int r)
{
    if(l == r) return l;
    int mid = (l+r)>>1, d = tree[tree[rt].l].sum;
    if(d >= num) return query(tree[rt].l,num,l,mid);
    return query(tree[rt].r,num-d,mid+1,r);
}
int Merge(int x,int y)
{
    if(!x) return y;
    if(!y) return x;
    tree[x].l = Merge(tree[x].l,tree[y].l);
    tree[x].r = Merge(tree[x].r,tree[y].r);
    tree[x].sum = tree[tree[x].l].sum+tree[tree[x].r].sum;
    return x;
}
int main()
{
    int n, m, x, y;
    n = read(); m = read();
    for(int i = 1; i <= n; i++){
        a[i] = read();
        id[a[i]] = i; prt[i] = i;
    }
    for(int i = 1; i <= m; i++){
        x = read(); y = read();
        prt[getpa(x)] = getpa(y);
    }
    for(int i = 1; i <= n; i++){
        update(root[getpa(i)],a[i],1,n);
    }
    m = read();
    while(m--){
        scanf("%s",s);
        x = read(); y = read();
        if(s[0] == 'Q'){
            int p = getpa(x);
            if(tree[root[p]].sum < y){
                printf("-1\n"); continue;
            }
            printf("%d\n",id[query(root[p],y,1,n)]);
        }
        else{
            int p = getpa(x), q = getpa(y);
            if(p != q){
                if(tree[root[p]].sum > tree[root[q]].sum){
                    swap(p,q);
                }
                prt[p] = q;
                root[q] = Merge(root[p],root[q]);
            }
        }
    }
    return 0;
}
```

hdu5709 

询问子树中与根节点距离小于等于d的节点包含的颜色种类数

维护两颗线段树 一颗维护x子树内深度在l,r内的点数，同种颜色有多个的话，保留深度最小的那个

另一颗维护x子树内每种颜色的最小深度

从底向上合并线段树，先合并t1，然后合并t2，发现有重复点，那么在t1里删去深度大的那个，查询直接在t1里区间求和即可

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int tot, tot1, n;
int T1[maxn], T2[maxn], dep[maxn];
int a[maxn], ver[maxn], Next[maxn], head[maxn];
struct node{ int l, r, x; } tree[maxn*400];
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
void init()
{
    tree[0].l = tree[0].r = tree[0].x = 0;
}
void update(int &rt,int num,int l,int r,int x)
{
    tree[++tot1] = tree[rt]; rt = tot1;
    tree[rt].x += x;
    if(l == r) return ;
    int mid = (l+r)>>1;
    if(mid >= num) update(tree[rt].l,num,l,mid,x);
    else update(tree[rt].r,num,mid+1,r,x);
}
int Merge(int x,int y,int f)
{
    if(!x) return y;
    if(!y) return x;
    int tmp = ++tot1;
    if(!f) tree[tmp].x = tree[x].x+tree[y].x;
    else if(!tree[x].l && !tree[x].r){
        tree[tmp].x = min(tree[x].x,tree[y].x);
        update(T1[f],max(tree[x].x,tree[y].x),1,n,-1);
    }
    tree[tmp].l = Merge(tree[x].l,tree[y].l,f);
    tree[tmp].r = Merge(tree[x].r,tree[y].r,f);
    return tmp;
}
void dfs(int u,int ff)
{
    dep[u] = dep[ff]+1;
    update(T1[u],dep[u],1,n,1);
    update(T2[u],a[u],1,n,dep[u]);
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        dfs(v,u);
        T1[u] = Merge(T1[u],T1[v],0);
        T2[u] = Merge(T2[u],T2[v],u);
    }
}
int query(int rt,int L,int R,int l,int r)
{
    if(l >= L && r <= R) return tree[rt].x;
    int mid = (l+r)>>1, res = 0;
    if(mid >= L) res += query(tree[rt].l,L,R,l,mid);
    if(mid < R) res += query(tree[rt].r,L,R,mid+1,r);
    return res;
}
int main()
{
    int t, m, x, y, lastans;
    scanf("%d",&t);
    while(t--){
        tot = tot1 = 0;
        init();
        scanf("%d%d",&n,&m);
        for(int i = 1; i <= n; i++){
            scanf("%d",&a[i]);
            T1[i] = T2[i] = head[i] = 0;
        }
        for(int i = 2; i <= n; i++){
            scanf("%d",&x);
            Add(x,i);
        }
        dfs(1,0);
        lastans = 0;
        while(m--){
            scanf("%d%d",&x,&y);
            x ^= lastans; y ^= lastans;
            y = min(n,y+dep[x]);
            lastans = query(T1[x],dep[x],y,1,n);
            printf("%d\n",lastans);
        }
    }
    return 0;
}
```

#### 线段树分裂

给出一个可重集 a（编号为 1），它支持以下操作：

0 p x y：将可重集 p 中大于等于 x 且小于等于y 的值放入一个新的可重集中（新可重集编号为从 2 开始的正整数，是上一次产生的新可重集的编号+1）。

1 p t：将可重集 t中的数放入可重集 p，且清空可重集t（数据保证在此后的操作中不会出现可重集 t）。

2 p x q：在 p 这个可重集中加入 x 个数字 q。

3 p x y：查询可重集 p 中大于等于 x 且小于等于 y 的值的个数。

4 p k：查询在 p 这个可重集中第k 小的数，不存在时输出 -1。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 5;
int tot;
int T[maxn];
struct node
{
    int l, r; ll sum;
} tree[maxn*200];
void update(int &rt,int num,int l,int r,int x)
{
    if(!rt){
        rt = ++tot;
        tree[rt].l = tree[rt].r = tree[rt].sum = 0;
    }
    tree[rt].sum += x;
    if(l == r) return ;
    int mid = (l+r)>>1;
    if(mid >= num) update(tree[rt].l,num,l,mid,x);
    else update(tree[rt].r,num,mid+1,r,x);
}
ll query(int rt,int L,int R,int l,int r)
{
    if(l >= L && r <= R) return tree[rt].sum;
    int mid = (l+r)>>1;
    ll res = 0;
    if(mid >= L) res += query(tree[rt].l,L,R,l,mid);
    if(mid < R) res += query(tree[rt].r,L,R,mid+1,r);
    return res;
}
int query(int rt,int num,int l,int r)
{
    if(l == r) return l;
    ll d = tree[tree[rt].l].sum;
    int mid = (l+r)>>1;
    if(d >= num) return query(tree[rt].l,num,l,mid);
    return query(tree[rt].r,num-d,mid+1,r);
}
void split(int x,int &y,ll z)
{
    y = ++tot;
    tree[y].l = tree[y].r = tree[y].sum = 0;
    ll num = tree[tree[x].l].sum;
    if(num < z) split(tree[x].r,tree[y].r,z-num);
    else swap(tree[x].r,tree[y].r);
    if(num > z) split(tree[x].l,tree[y].l,z);
    tree[y].sum = tree[x].sum-z;
    tree[x].sum = z;
    return ;
}
int Merge(int x,int y)
{
    if(!x) return y;
    if(!y) return x;
    tree[x].l = Merge(tree[x].l,tree[y].l);
    tree[x].r = Merge(tree[x].r,tree[y].r);
    tree[x].sum = tree[x].sum+tree[y].sum;
    return x;
}
int main()
{
    int n, m, x, id = 1;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++){
        scanf("%d",&x);
        update(T[1],i,1,n,x);
    }
    int op, p, y;
    while(m--){
        scanf("%d%d%d",&op,&p,&x);
        if(op == 0){
            scanf("%d",&y);
            ll tmp1 = query(T[p],1,y,1,n);
            ll tmp2 = query(T[p],x,y,1,n);
            split(T[p],T[++id],tmp1-tmp2);
            int tmp = 0;
            split(T[id],tmp,tmp2);
            T[p] = Merge(T[p],tmp);
        }
        else if(op == 1){
            T[p] = Merge(T[p],T[x]);
            T[x] = 0;
        }
        else if(op == 2){
            scanf("%d",&y);
            update(T[p],y,1,n,x);
        }
        else if(op == 3){
            scanf("%d",&y);
            printf("%lld\n",query(T[p],x,y,1,n));
        }
        else{
            if(tree[T[p]].sum < x) printf("-1\n");
            else printf("%d\n",query(T[p],x,1,n));
        }
    }
    return 0;
}
```

#### 线段树染色

P2161 [SHOI2009]会场预约

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
char s[5];
int ans, tmp, col;
int del[maxn*2]; //颜色被删除，则打一个1标记
struct node{ int l, r, tag, v; } tree[maxn*4]; //v代表该区间颜色是否相同，tag表示染的颜色
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r;
    tree[k].tag = 0; tree[k].v = 1;
    if(l == r) return ;
    int mid = (l+r)>>1;
    build(k<<1,l,mid); build(k<<1|1,mid+1,r);
}
void pushdown(int k) //能被下放的，必然是与染色区间相交的区间，所以该区间颜色一定不一致
{
    tree[k].v = 0;
    if(!tree[k].tag) return ;
    tree[k<<1].tag = tree[k<<1|1].tag = tree[k].tag;
    tree[k].tag = 0;
}
void update(int k,int l,int r) //对符合条件的区间进行染色
{
    if(tree[k].v){
        if(tree[k].tag && !del[tree[k].tag]) ans--, tmp++;
        del[tree[k].tag] = 1;
        tree[k].tag = col;
        return ;
    }
    tree[k].tag = col; tree[k].v = 1;
    update(k<<1,l,r); update(k<<1|1,l,r);
}
void modify(int k,int l,int r) //找到在染色区间内的区间
{
    if(tree[k].l >= l && tree[k].r <= r){
        update(k,l,r); return ;
    }
    pushdown(k);
    int mid = (tree[k].l+tree[k].r)>>1;
    if(mid >= l) modify(k<<1,l,r);
    if(mid < r) modify(k<<1|1,l,r);
}
int main()
{
    int n, x, y;
    scanf("%d",&n);
    build(1,1,1e5);
    for(int i = 1; i <= n; i++){
        scanf("%s",s);
        if(s[0] == 'A'){
            ans++; tmp = 0; col++;
            scanf("%d%d",&x,&y);
            modify(1,x,y);
            printf("%d\n",tmp);
        }
        else printf("%d\n",ans);
    }
    return 0;
}
```

#### 延迟标记

BZOJ1798 线段树+延迟标记

下传时要先考虑乘的影响，在考虑加的影响

```c++
#include<cstdio>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
int n, m;
ll num[maxn], p, ans;
struct node{ int l, r; ll sum, mul, add; } tree[maxn*4];
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r;
    tree[k].add = 0; tree[k].mul = 1;
    if(l == r){ tree[k].sum = num[l]; return ; }
    int mid = (l+r)>>1;
    build(k<<1,l,mid); build(k<<1|1,mid+1,r);
    tree[k].sum = (tree[k<<1].sum+tree[k<<1|1].sum)%p;
}
void Add(int k,int v)
{
    tree[k].add = (tree[k].add+v)%p;
    tree[k].sum = (tree[k].sum+(tree[k].r-tree[k].l+1)*v%p)%p;
}
void Mul(int k,int v)
{
    tree[k].add = tree[k].add*v%p;
    tree[k].mul = tree[k].mul*v%p;
    tree[k].sum = tree[k].sum*v%p;
}
void pushdown(int k)
{
    if(tree[k].add == 0 && tree[k].mul == 1) return ;
    tree[k<<1].sum = (tree[k<<1].sum*tree[k].mul+tree[k].add*(tree[k<<1].r-tree[k<<1].l+1))%p;
    tree[k<<1|1].sum = (tree[k<<1|1].sum*tree[k].mul+tree[k].add*(tree[k<<1|1].r-tree[k<<1|1].l+1))%p;
    tree[k<<1].add = (tree[k<<1].add*tree[k].mul+tree[k].add)%p;
    tree[k<<1|1].add = (tree[k<<1|1].add*tree[k].mul+tree[k].add)%p;
    tree[k<<1].mul = tree[k<<1].mul*tree[k].mul%p;
    tree[k<<1|1].mul = tree[k<<1|1].mul*tree[k].mul%p;
    tree[k].add = 0; tree[k].mul = 1;
}
void modify1(int k,int l,int r,int v)
{
    if(tree[k].l > r || tree[k].r < l) return ;
    if(tree[k].l >= l && tree[k].r <= r) return Add(k,v);
    pushdown(k);
    tree[k].add = 0;
    modify1(k<<1,l,r,v); modify1(k<<1|1,l,r,v);
    tree[k].sum = (tree[k<<1].sum+tree[k<<1|1].sum)%p;
}
void modify2(int k,int l,int r,int v)
{
    if(tree[k].l > r || tree[k].r < l) return ;
    if(tree[k].l >= l && tree[k].r <= r) return Mul(k,v);
    pushdown(k);
    tree[k].mul = 1;
    modify2(k<<1,l,r,v); modify2(k<<1|1,l,r,v);
    tree[k].sum = (tree[k<<1].sum+tree[k<<1|1].sum)%p;
}
void query(int k,int l,int r)
{
    if(tree[k].l > r || tree[k].r < l) return ;
    if(tree[k].l >= l && tree[k].r <= r){
        ans = (ans+tree[k].sum)%p; return ;
    }
    pushdown(k);
    query(k<<1,l,r);
    query(k<<1|1,l,r);
}
int main()
{
    scanf("%d%lld",&n,&p);
    for(int i = 1; i <= n; i++) scanf("%lld",&num[i]);
    build(1,1,n);
    scanf("%d",&m);
    for(int i = 1,op,l,r,v; i <= m; i++){
        scanf("%d%d%d",&op,&l,&r);
        if(op == 1){
            scanf("%d",&v);
            modify2(1,l,r,v);
        }
        else if(op == 2){
            scanf("%d",&v);
            modify1(1,l,r,v);
        }
        else{
            ans = 0; query(1,l,r);
            printf("%lld\n",ans);
        }
    }
    return 0;
}
```

#### 扫描线

poj1151

```c++
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 205;
double a[maxn];
struct node1{ double x, y1, y2; int k; } q[maxn];
struct node2{ int l, r, cover; double len; } tree[maxn*4];
bool cmp(node1 q1,node1 q2){ return q1.x < q2.x; }
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r;
    tree[k].cover = 0; tree[k].len = 0;
    if(l == r) return ;
    int mid = (l+r)>>1;
    build(k<<1,l,mid); build(k<<1|1,mid+1,r);
}
void update(int k,int l,int r,int x)
{
    if(tree[k].l >= l && tree[k].r <= r) tree[k].cover += x;
    if(tree[k].l == tree[k].r){
        if(tree[k].cover > 0) tree[k].len = a[tree[k].r+1]-a[tree[k].l];
        else tree[k].len = 0;
        return ;
    }
    int mid = (tree[k].l+tree[k].r)>>1;
    if(mid >= l) update(k<<1,l,r,x);
    if(mid < r) update(k<<1|1,l,r,x);
    if(tree[k].cover > 0) tree[k].len = a[tree[k].r+1]-a[tree[k].l];
    else tree[k].len = tree[k<<1].len+tree[k<<1|1].len;
    return ;
}
int main()
{
    int n, cnt, mycase = 0;
    double x1, x2, y1, y2, ans;
    while(scanf("%d",&n) && n){
        cnt = 0;
        for(int i = 1; i <= n; i++){
            scanf("%lf%lf%lf%lf",&x1,&y1,&x2,&y2);
            q[++cnt].x = x1; q[cnt].y1 = y1; q[cnt].y2 = y2; q[cnt].k = 1;
            a[cnt] = y1;
            q[++cnt].x = x2; q[cnt].y1 = y1; q[cnt].y2 = y2; q[cnt].k = -1;
            a[cnt] = y2;
        }
        sort(q+1,q+cnt+1,cmp);
        sort(a+1,a+cnt+1);
        cnt = unique(a+1,a+cnt+1)-a-1;
        build(1,1,cnt-1);
        ans = 0;
        for(int i = 1; i < 2*n; i++){
            int l = lower_bound(a+1,a+cnt+1,q[i].y1)-a;
            int r = lower_bound(a+1,a+cnt+1,q[i].y2)-a-1;
            update(1,l,r,q[i].k);
            ans += tree[1].len*(q[i+1].x-q[i].x);
        }
        printf("Test case #%d\n",++mycase);
        printf("Total explored area: %.2f\n\n",ans);
    }
    return 0;
}
```

#### 李超线段树

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
const double eps = 1e-12;
char s[20];
struct node
{
    int l, r, cover; //l,r代表线段的左右边界，cover代表是否被覆盖
    double k, b;
} tree[maxn*4];
void build(int k,int l,int r)
{
    tree[k].l = 1; tree[k].r = 50000;
    tree[k].k = tree[k].b = tree[k].cover = 0;
    if(l == r) return ;
    int mid = (l+r)>>1;
    build(k<<1,l,mid); build(k<<1|1,mid+1,r);
}
double calc(node a,int x){ return a.k*x+a.b; }
int cross(node a,node b){ return floor((a.b-b.b)/(b.k-a.k)); }
void update(int k,int l,int r,node line)
{
    if(l >= line.l && r <= line.r){
        if(!tree[k].cover) tree[k] = line, tree[k].cover = 1;
        else if(calc(line,l) > calc(tree[k],l)+eps && calc(line,r) > calc(tree[k],r)+eps){
            tree[k] = line;
        }
        else if(calc(line,l) > calc(tree[k],l)+eps || calc(line,r) > calc(tree[k],r)+eps){
            int mid = (l+r)>>1;
            if(calc(line,mid) > calc(tree[k],mid)+eps){
                node tmp = tree[k]; tree[k] = line; line = tmp;

            }
            if(cross(line,tree[k])-mid < -eps) update(k<<1,l,mid,line);
            else update(k<<1|1,mid+1,r,line);
        }
    }
    else{
        int mid = (l+r)>>1;
        if(mid >= line.l) update(k<<1,l,mid,line);
        if(mid < line.r) update(k<<1|1,mid+1,r,line);
    }
}
double query(int k,int l,int r,int x)
{
    if(l == r) return calc(tree[k],x);
    else{
        int mid = (l+r)>>1;
        double ans = calc(tree[k],x);
        if(mid >= x) ans = max(ans,query(k<<1,l,mid,x));
        else ans = max(ans,query(k<<1|1,mid+1,r,x));
        return ans;
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    build(1,1,50000);
    while(n--){
        scanf("%s",s);
        if(s[0] == 'P'){
            double K, B;
            scanf("%lf%lf",&B,&K);
            node now; now.l = 1, now.r = 50000;
            now.k = K; now.b = B-K;
            update(1,1,50000,now);
        }
        else{
            int x;
            scanf("%d",&x);
            printf("%d\n",(int)floor(query(1,1,50000,x)/100));
        }
    }
    return 0;
}
```

P4069 [SDOI2016]游戏

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int mod = 1e9;
const int maxn = 2e5 + 5;
const ll inf = 123456789123456789ll;
int tot;
int ver[maxn], Next[maxn], head[maxn];
int siz[maxn], fa[maxn], dep[maxn], son[maxn];
int seg[maxn], top[maxn], rev[maxn];
ll dis[maxn], edge[maxn];
pair<ll,ll> li[maxn];
void Add(int x,int y,ll z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
void dfs1(int u,int ff)
{
    siz[u] = 1;
    fa[u] = ff;
    dep[u] = dep[ff]+1;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff) continue;
        dis[v] = dis[u]+edge[i];
        dfs1(v,u);
        siz[u] += siz[v];
        if(siz[v] > siz[son[u]]) son[u] = v;
    }
}
void dfs2(int u,int ff)
{
    if(son[u]){
        seg[son[u]] = ++seg[0];
        top[son[u]] = top[u];
        rev[seg[0]] = son[u];
        dfs2(son[u],u);
    }
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(top[v]) continue;
        seg[v] = ++seg[0];
        top[v] = v;
        rev[seg[0]] = v;
        dfs2(v,u);
    }
}
int lca(int x,int y)
{
    int fx = top[x], fy = top[y];
    while(fx != fy){
        if(dep[fx] < dep[fy]) swap(x,y), swap(fx,fy);
        x = fa[fx]; fx = top[x];
    }
    if(dep[x] > dep[y]) swap(x,y);
    return x;
}
struct node
{
    int l, r, id;
    ll mn;
} tree[maxn*4];
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r;
    tree[k].id = 0; tree[k].mn = inf;
    if(l == r) return ;
    int mid = (l+r)>>1;
    build(k<<1,l,mid); build(k<<1|1,mid+1,r);
}
ll calc(int id,int x){ return li[id].first*dis[rev[x]]+li[id].second; }
void pushup(int k)
{
    tree[k].mn = min(tree[k].mn,min(tree[k<<1].mn,tree[k<<1|1].mn));
}
void update(int k,int L,int R,int id)
{
    int l = tree[k].l, r = tree[k].r;
    int &cur = tree[k].id;
    if(l >= L && r <= R){
        if(calc(id,l) <= calc(cur,l) && calc(id,r) <= calc(cur,r)){
            cur = id;
            tree[k].mn = min(tree[k].mn,min(calc(cur,l),calc(cur,r)));
        }
        else if(calc(id,l) <= calc(cur,l) || calc(id,r) <= calc(cur,r)){
            int mid = (l+r)>>1;
            if(calc(id,mid) <= calc(cur,mid)) swap(cur,id);
            update(k<<1,L,R,id);
            update(k<<1|1,L,R,id);
            tree[k].mn = min(tree[k].mn,min(calc(cur,l),calc(cur,r)));
            pushup(k);
        }
    }
    else{
        int mid = (l+r)>>1;
        if(mid >= L) update(k<<1,L,R,id);
        if(mid < R) update(k<<1|1,L,R,id);
        pushup(k);
    }
}
ll query(int k,int l,int r)
{
    if(tree[k].l >= l && tree[k].r <= r){
        return tree[k].mn;
    }
    int mid = (tree[k].l+tree[k].r)>>1;
    ll ans = inf;
    ans = min(ans,calc(tree[k].id,max(l,tree[k].l)));
    ans = min(ans,calc(tree[k].id,min(r,tree[k].r)));
    if(mid >= l) ans = min(ans,query(k<<1,l,r));
    if(mid < r) ans = min(ans,query(k<<1|1,l,r));
    return ans;
}
void modify(int x,int y,int id)
{
    int fx = top[x], fy = top[y];
    while(fx != fy){
        if(dep[fx] < dep[fy]) swap(x,y), swap(fx,fy);
        update(1,seg[fx],seg[x],id);
        x = fa[fx]; fx = top[x];
    }
    if(dep[x] > dep[y]) swap(x,y);
    update(1,seg[x],seg[y],id);
}
ll ask(int x,int y)
{
    int fx = top[x], fy = top[y];
    ll ans = inf;
    while(fx != fy){
        if(dep[fx] < dep[fy]) swap(x,y), swap(fx,fy);
        ans = min(ans,query(1,seg[fx],seg[x]));
        x = fa[fx]; fx = top[x];
    }
    if(dep[x] > dep[y]) swap(x,y);
    ans = min(ans,query(1,seg[x],seg[y]));
    return ans;
}
int main()
{
    int n, m;
    scanf("%d%d",&n,&m);
    for(int i = 1; i < n; i++){
        int x, y; ll z;
        scanf("%d%d%lld",&x,&y,&z);
        Add(x,y,z); Add(y,x,z);
    }
    dfs1(1,0);
    seg[0] = seg[1] = top[1] = rev[1] = 1;
    dfs2(1,0);
    build(1,1,n);
    li[0] = make_pair(0,inf);
    int cnt = 0;
    while(m--){
        int op, st, ed;
        ll x, y;
        scanf("%d%d%d",&op,&st,&ed);
        if(op == 1){
            scanf("%lld%lld",&x,&y);
            int tmp = lca(st,ed);
            li[++cnt] = make_pair(-x,x*dis[st]+y);
            modify(st,tmp,cnt);
            li[++cnt] = make_pair(x,x*dis[st]-2*x*dis[tmp]+y);
            modify(tmp,ed,cnt);
        }
        else{
            printf("%lld\n",ask(st,ed));
        }
    }
    return 0;
}
```

可持久化李超线段树

牛客挑战赛42E

对于dp方程 f[i] = f[j] + (h[i] - h[j])^2 + sum[i-1] -sum[j],转化为 f[i] - h[i]^2 - sum[i-1] = 2*h[j]*h[i] + f[j] + h[j]^2 - sum[j]

斜率k为-2*h[j] ，截距b为 f[j]+h[j]^2-sum[j]，想要f[i]最小

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int mod = 1e9;
const int maxn = 1e5 + 5;
ll h[maxn], sum[maxn], f[maxn];
int times;
int T[maxn];
pair<ll,ll> li[maxn]; //存放斜率和截距，若数据较大改为double，添加eps = 1e-12
struct node
{
    int l, r, id;
} tree[maxn*40];
ll calc(int id,int x)
{
    return li[id].first*x+li[id].second;
}
void update(int &rt,int l,int r,int nid)
{
    tree[++times] = tree[rt]; rt = times;
    int &cur = tree[rt].id;
    if(l == r){
        if(calc(cur,l) > calc(nid,l)) cur = nid;
        return ;
    }
    int mid = (l+r)>>1;
    if(calc(cur,mid) > calc(nid,mid)) swap(cur,nid);
    if(calc(cur,l) > calc(nid,l)) update(tree[rt].l,l,mid,nid);
    if(calc(cur,r) > calc(nid,r)) update(tree[rt].r,mid+1,r,nid);
}
ll query(int rt,int l,int r,int x)
{
    if(l == r) return calc(tree[rt].id,x);
    int mid = (l+r)>>1;
    return min(calc(tree[rt].id,x),x <= mid ? query(tree[rt].l,l,mid,x) : query(tree[rt].r,mid+1,r,x));
}
int main()
{
    int n, m;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++) scanf("%lld",&h[i]);
    for(int i = 1; i <= n; i++){
        int x;
        scanf("%d",&x);
        sum[i] = sum[i-1]+x;
    }
    li[0] = make_pair(0,1e18);
    for(int i = 1; i <= n; i++){
        if(i > 1) f[i] = query(T[i-1],1,1e4,h[i])+sum[i-1]+h[i]*h[i];
        li[i] = make_pair(-2*h[i],f[i]+h[i]*h[i]-sum[i]);
        update(T[i]=T[i-1],1,1e4,i);
    }
    ll lastans = 0;
    while(m--){
        int x, y;
        scanf("%d%d",&x,&y);
        x = ((x^lastans)%n+n)%n+1;
        if(x == 1) lastans = 0, printf("%lld\n",lastans);
        else{
            lastans = query(T[x-1],1,1e4,y)+sum[x-1]+(ll)y*y;
            printf("%lld\n",lastans);
        }
    }
    return 0;
}
```

#### 时间分治

有加边和删边操作，维护每条边的存在时间，将其加到对应的线段树区间中，通过遍历线段树，进入一个区间时，用并查集将这些边连起来，退出时再删掉

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int mod = 998244353;
const int maxn = 2e5 + 5;
int ans;
int a[maxn], prt[maxn], siz[maxn];
struct qnode{ int op, x, y; } ques[maxn];
map<pair<int,int>,int> mp;
struct node
{
    int l, r;
    vector<int> id;
} tree[maxn*4];
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r;
    if(l == r) return ;
    int mid = (l+r)>>1;
    build(k<<1,l,mid); build(k<<1|1,mid+1,r);
}
void update(int k,int l,int r,int x)
{
    if(tree[k].l >= l && tree[k].r <= r){
        tree[k].id.push_back(x);
        return ;
    }
    int mid = (tree[k].l+tree[k].r)>>1;
    if(mid >= l) update(k<<1,l,r,x);
    if(mid < r) update(k<<1|1,l,r,x);
}
int getpa(int x)
{
    if(prt[x] == x) return x;
    return getpa(prt[x]);
}
void dfs(int k)
{
    vector<pair<int,int> > q1;
    vector<int> q2;
    int x, y, fx, fy;
    for(int i = 0; i < (int)tree[k].id.size(); i++){
        x = ques[tree[k].id[i]].x, y = ques[tree[k].id[i]].y;
        fx = getpa(x), fy = getpa(y);
        if(fx == fy) continue;
        if(siz[fx] > siz[fy]) swap(fx,fy);
        if(siz[fx] > 1) ans--;
        if(siz[fy] > 1) ans--;
        q1.push_back(make_pair(fx,fy));
        q2.push_back(siz[fx]);
        siz[fy] += siz[fx]; prt[fx] = fy;
        if(siz[fy] > 1) ans++;
    }
    if(tree[k].l == tree[k].r){
        if(ques[tree[k].l].op == 3){
            printf("%d\n",ans);
        }
    }
    else{
        dfs(k<<1); dfs(k<<1|1);
    }
    for(int i = (int)q1.size()-1; i >= 0; i--){
        x = q1[i].first, y = q1[i].second;
        ans--;
        siz[y] -= q2[i]; prt[x] = x;
        if(siz[x] > 1) ans++;
        if(siz[y] > 1) ans++;
    }
    q1.clear(); q2.clear();
}
int main()
{
    int n, op, x, y;
    scanf("%d",&n);
    int cnt = 0;
    for(int i = 1; i <= n; i++){
        scanf("%d",&op);
        if(op == 1 || op == 2){
            scanf("%d%d",&x,&y);
            a[++cnt] = x; a[++cnt] = y;
        }
        ques[i] = (qnode){op,x,y};
    }
    sort(a+1,a+cnt+1);
    cnt = unique(a+1,a+cnt+1)-a-1;
    for(int i = 1; i <= cnt; i++) prt[i] = i, siz[i] = 1;
    build(1,1,n);
    for(int i = 1; i <= n; i++){
        int op = ques[i].op;
        int x = ques[i].x, y = ques[i].y;
        if(op == 1){
            x = lower_bound(a+1,a+cnt+1,x)-a;
            y = lower_bound(a+1,a+cnt+1,y)-a;
            if(x > y) swap(x,y);
            pair<int,int> tmp = make_pair(x,y);
            if(mp.count(tmp)) continue;
            mp[tmp] = i;
        }
        else if(op == 2){
            x = lower_bound(a+1,a+cnt+1,x)-a;
            y = lower_bound(a+1,a+cnt+1,y)-a;
            if(x > y) swap(x,y);
            pair<int,int> tmp = make_pair(x,y);
            if(!mp.count(tmp)) continue;
            update(1,mp[tmp],i-1,i);
            auto it = mp.find(tmp);
            mp.erase(it);
        }
        ques[i].x = x; ques[i].y = y;
    }
    for(map<pair<int,int>,int>::iterator it = mp.begin(); it != mp.end(); it++){
        auto p = *it;
        int tmp = p.second;
        update(1,tmp,n,tmp);
    }
    dfs(1);
    return 0;
}
```

### 主席树

#### 树上主席树

2019南昌网络赛 J Distance on the tree

主席树+倍增lca

求树上两点之间路径上边小于k的边数

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int ver[maxn*2], edge[maxn*2], Next[maxn*2], head[maxn];
int a[maxn], T[maxn], dep[maxn], fa[maxn][25];
int tot, t, times, ans, cnt;
struct node1{ int l, r, sum; } tree[maxn*40];
template<class T>inline void read(T &res)
{
    char c;T flag=1;
    while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;res=c-'0';
    while((c=getchar())>='0'&&c<='9')res=res*10+c-'0';res*=flag;
}
void Add(int x,int y,int z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
void init()
{
    T[0] = times = 0;
    tree[0].l = tree[0].r = tree[0].sum = 0;
}
void update(int &rt,int num,int l,int r)
{
    tree[++times] = tree[rt]; rt = times;
    tree[rt].sum++;
    if(l == r) return ;
    int mid = (l+r)>>1;
    if(num <= mid) update(tree[rt].l,num,l,mid);
    else update(tree[rt].r,num,mid+1,r);
}
void dfs(int u,int f,int z)
{
    T[u] = T[f];
    dep[u] = dep[f]+1;
    int p = lower_bound(a+1,a+cnt+1,z)-a;
    if(u != 1) update(T[u],p,1,maxn);
    for(int i = 0; i <= 19; i++) fa[u][i+1] = fa[fa[u][i]][i];
    for(int i = head[u],v; i; i = Next[i]){
        v = ver[i];
        if(v == f) continue;
        fa[v][0] = u;
        dfs(v,u,edge[i]);
    }
}
int lca(int x,int y)
{
    if(dep[x] < dep[y]) swap(x,y);
    for(int i = 20; i >= 0; i--){
        if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];
        if(x == y) return x;
    }
    for(int i = 20; i >= 0; i--){
        if(fa[x][i] != fa[y][i]){
            x = fa[x][i];
            y = fa[y][i];
        }
    }
    return fa[x][0];
}
void query(int t1,int t2,int k,int l,int r)
{
    if(r <= k){
        ans += tree[t2].sum-tree[t1].sum;
        return ;
    }
    int mid = (l+r)>>1;
    if(k <= mid) query(tree[t1].l,tree[t2].l,k,l,mid);
    else{
        ans += tree[tree[t2].l].sum-tree[tree[t1].l].sum;
        query(tree[t1].r,tree[t2].r,k,mid+1,r);
    }
}
int main()
{
    int n, m, x, y, z;
    scanf("%d%d",&n,&m);
    for(int i = 1; i < n; i++){
        x = read(); y = read(); z = read();
        Add(x,y,z); Add(y,x,z);
        a[i] = z;
    }
    sort(a+1,a+n+1);
    cnt = unique(a+1,a+n+1)-a-1;
    init(); dfs(1,0,0);
    for(int i = 1,res; i <= m; i++){
        res = 0;
        x = read(); y = read(); z = read();
        if(!z) printf("0\n");
        else{
            int tmp = lca(x,y);
            z = upper_bound(a+1,a+cnt+1,z)-a-1;
            if(x != tmp) ans = 0, query(T[tmp],T[x],z,1,maxn), res += ans;
            if(y != tmp) ans = 0, query(T[tmp],T[y],z,1,maxn), res += ans;
            printf("%d\n",res);
        }
    }
    return 0;
}
```

牛客 树的距离

一棵有根数树上有N个节点，1号点是他的根，每条边都有一个距离，对于某个点x,以x为根的子树上，所有与x距离大于等于k的点与x的距离之和。  

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 5;
int ver[maxn*2], edge[maxn*2], Next[maxn*2], head[maxn];
int T[maxn], in[maxn], out[maxn];
int tot, times, t;
ll dis[maxn], sum_dis, sum_cnt;
struct node{ int l, r; ll sum, num; } tree[maxn*40];
void Add(int x,int y,int z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
void init()
{
    T[0] = 0;
    tree[0].l = tree[0].r = tree[0].sum = tree[0].num = 0;
}
void update(int &rt,ll l,ll r,ll x)
{
    tree[++times] = tree[rt]; rt = times;
    tree[rt].sum += x; tree[rt].num++;
    if(l == r) return ;
    ll mid = (l+r)>>1ll;
    if(x <= mid) update(tree[rt].l,l,mid,x);
    else update(tree[rt].r,mid+1,r,x);
}
void dfs(int u,int f)
{
    in[u] = ++t; T[t] = T[t-1];
    update(T[t],1ll,(ll)2e11,dis[u]);
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == f) continue;
        dis[v] = dis[u]+edge[i];
        dfs(v,u);
    }
    out[u] = t;
}
void query(int t1,int t2,ll k,ll l,ll r)
{
    if(l >= k){
        sum_dis += tree[t2].sum-tree[t1].sum;
        sum_cnt += tree[t2].num-tree[t1].num;
        return ;
    }
    ll mid = (l+r)>>1ll;
    if(k <= mid){
        sum_dis += tree[tree[t2].r].sum-tree[tree[t1].r].sum;
        sum_cnt += tree[tree[t2].r].num-tree[tree[t1].r].num;
        query(tree[t1].l,tree[t2].l,k,l,mid);
    }
    else query(tree[t1].r,tree[t2].r,k,mid+1,r);
}
int main()
{
    int n, q;
    scanf("%d",&n);
    for(int i = 1,x,y; i < n; i++){
        scanf("%d%d",&x,&y);
        Add(x,i+1,y); Add(i+1,x,y);
    }
    init();
    dfs(1,0);
    scanf("%d",&q);
    ll k;
    for(int i = 1,x; i <= q; i++){
        scanf("%d%lld",&x,&k);
        k += dis[x];
        sum_dis = sum_cnt = 0;
        query(T[in[x]],T[out[x]],k,1ll,(ll)2e11);
        printf("%lld\n",sum_dis-sum_cnt*dis[x]);
    }
    return 0;
}
```

牛客 ABCBA

给出一颗n个结点n-1条边的树，再给出一个长度为n的字符串s，树上的每个点都表示一个字符，点i表示的字符是s[i]，其只包含大写拉丁字符。再给出q个查询，对于每个查询，会给出两个整数u,v,表示树上的两个点。对于每个查询你将从点v开始走最短路径走到点u，并按行走的顺序连接每个结点上的字符，形成一个新的字符串H,你需要计算字符串H中包含子串‘ABCBA’的个数。子串的定义就是存在任意下标a<b<c<d<e，那么”s[a]s[b]s[c]s[d]s[e]”就构成s的一个子串。如”ABC”的子串有”A”、”B”、”C”、”AB”、”AC”、”BC”、”ABC”。  

利用该串为回文串的性质

```c++
#include<bits/stdc++.h>
using namespace std;
const int mod = 10007;
const int maxn = 3e4 + 5;
char s[maxn];
int tot, times, n;
int f[maxn][21], dep[maxn], T[maxn];
int ver[maxn*2], Next[maxn*2], head[maxn];
struct node
{
    int l, r, sum;
    int A, AB, ABC, ABCB, B, BC, BCB, BCBA, C, CB, CBA, BA;
    node operator + (const node &rhs) const{
        node tmp;
        tmp.sum = (sum+rhs.sum+A*rhs.BCBA+AB*rhs.CBA+ABC*rhs.BA+ABCB*rhs.A)%mod;
        tmp.A = (A+rhs.A)%mod;
        tmp.AB = (AB+rhs.AB+A*rhs.B)%mod;
        tmp.ABC = (ABC+rhs.ABC+A*rhs.BC+AB*rhs.C)%mod;
        tmp.ABCB = (ABCB+rhs.ABCB+A*rhs.BCB+AB*rhs.CB+ABC*rhs.B)%mod;
        tmp.B = (B+rhs.B)%mod;
        tmp.BC = (BC+rhs.BC+B*rhs.C)%mod;
        tmp.BCB = (BCB+rhs.BCB+B*rhs.CB+BC*rhs.B)%mod;
        tmp.BCBA = (BCBA+rhs.BCBA+B*rhs.CBA+BC*rhs.BA+BCB*rhs.A)%mod;
        tmp.C = (C+rhs.C)%mod;
        tmp.CB = (CB+rhs.CB+C*rhs.B)%mod;
        tmp.CBA = (CBA+rhs.CBA+C*rhs.BA+CB*rhs.A)%mod;
        tmp.BA = (BA+rhs.BA+B*rhs.A)%mod;
        return tmp;
    }
} tree[maxn*40];
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
void init()
{
    T[0] = times = 0;
    tree[0].l = tree[0].r = tree[0].sum = 0;
    tree[0].A = tree[0].AB = tree[0].ABC = tree[0].ABCB = tree[0].B = tree[0].BC = tree[0].BCB = tree[0].BCBA = tree[0].C = tree[0].CB = tree[0].CBA = tree[0].BA = 0;
}
void update(int &rt,int num,int l,int r,char c)
{
    tree[++times] = tree[rt];
    rt = times;
    if(l == r){
        if(c == 'A') tree[rt].A = 1;
        else if(c == 'B') tree[rt].B = 1;
        else if(c == 'C') tree[rt].C = 1;
        return ;
    }
    int mid = (l+r)>>1;
    if(mid >= num) update(tree[rt].l,num,l,mid,c);
    else update(tree[rt].r,num,mid+1,r,c);
    int tl = tree[rt].l, tr = tree[rt].r;
    tree[rt] = tree[tree[rt].l]+tree[tree[rt].r];
    tree[rt].l = tl; tree[rt].r = tr;
}
void dfs(int u,int fa)
{
    f[u][0] = fa;
    dep[u] = dep[fa]+1;
    update(T[u]=T[fa],dep[u],1,n,s[u]);
    for(int i = 0; i <= 19; i++) f[u][i+1] = f[f[u][i]][i];
    for(int i = head[u]; i; i = Next[i]){
        if(ver[i] == fa) continue;
        dfs(ver[i],u);
    }
}
int lca(int x,int y)
{
    if(dep[x] < dep[y]) swap(x,y);
    for(int i = 20; i >= 0; i--){
        if(dep[f[x][i]] >= dep[y]) x = f[x][i];
        if(x == y) return x;
    }
    for(int i = 20; i >= 0; i--){
        if(f[x][i] != f[y][i]){
            x = f[x][i]; y = f[y][i];
        }
    }
    return f[x][0];
}
node query(int rt,int L,int R,int l,int r)
{
    if(l >= L && r <= R) return tree[rt];
    int mid = (l+r)>>1;
    if(mid >= R) return query(tree[rt].l,L,R,l,mid);
    else if(mid < L) return query(tree[rt].r,L,R,mid+1,r);
    return query(tree[rt].l,L,R,l,mid)+query(tree[rt].r,L,R,mid+1,r);
}
int main()
{
    int m, x, y;
    scanf("%d%d%s",&n,&m,s+1);
    for(int i = 1; i < n; i++){
        scanf("%d%d",&x,&y);
        Add(x,y); Add(y,x);
    }
    init();
    dfs(1,0);
    while(m--){
        scanf("%d%d",&x,&y);
        int tmp = lca(x,y), ans = 0;
        //printf("%d\n",tmp);
        if(x == tmp){
            node p = query(T[y],dep[x],dep[y],1,n);
            ans = (p.sum+mod)%mod;
        }
        else if(y == tmp){
            node p = query(T[x],dep[y],dep[x],1,n);
            ans = (p.sum+mod)%mod;
        }
        else{
            node p1 = query(T[x],dep[tmp],dep[x],1,n);
            node p2 = query(T[y],dep[tmp]+1,dep[y],1,n);
            ans = (p1.sum+p2.sum+p1.A*p2.BCBA+p1.BA*p2.CBA+p1.CBA*p2.BA+p1.BCBA*p2.A)%mod;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

#### 静态区间第k大

POJ2104 K-th Number

```c++
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 1e5 + 5;
int a[maxn], b[maxn], T[maxn], tot;
struct node{ int l, r, sum; } tree[maxn*20];
void init()
{
    tot = T[0] = 0;
    tree[0].l = tree[0].r = tree[0].sum = 0;
}
void update(int num,int &rt,int l,int r)
{
    tree[++tot] = tree[rt]; rt = tot;
    tree[rt].sum++;
    if(l == r) return ;
    int mid = (l+r)>>1;
    if(num <= mid) update(num,tree[rt].l,l,mid);
    else update(num,tree[rt].r,mid+1,r);
}
int query(int t1,int t2,int k,int l,int r)
{
    int d = tree[tree[t2].l].sum-tree[tree[t1].l].sum;
    if(l == r) return l;
    int mid = (l+r)>>1;
    if(k <= d) return query(tree[t1].l,tree[t2].l,k,l,mid);
    return query(tree[t1].r,tree[t2].r,k-d,mid+1,r);
}
int main()
{
    int n, q;
    scanf("%d%d",&n,&q);
    for(int i = 1; i <= n; i++) scanf("%d",&a[i]), b[i] = a[i];
    sort(b+1,b+n+1);
    int cnt = unique(b+1,b+n+1)-b-1;
    init();
    for(int i = 1; i <= n; i++){
        T[i] = T[i-1];
        int x = lower_bound(b+1,b+cnt+1,a[i])-b;
        update(x,T[i],1,cnt);
    }
    for(int i = 1,l,r,k; i <= q; i++){
        scanf("%d%d%d",&l,&r,&k);
        printf("%d\n",b[query(T[l-1],T[r],k,1,cnt)]);
    }
    return 0;
}
```

#### 动态区间第k大

P2617 Dynamic Rankings

树状数组套主席树

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int a[maxn], b[maxn*2], T[maxn], X[maxn], Y[maxn];
int cnt, times, totx, toty;
char s[5];
struct node{ int l, r, sum; } tree[maxn*400];
struct node1{ int l, r, k; } q[maxn];
inline int read()
{
    int s = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ (s *= 10) += ch-'0'; ch = getchar(); }
    return s*f;
}
int lowbit(int x){ return x&(-x); }
void init()
{
    T[0] = times = 0;
    tree[0].l = tree[0].r = tree[0].sum = 0;
}
void update(int &rt,int num,int l,int r,int x)
{
    if(!rt) tree[++times] = tree[rt], rt = times;
    tree[rt].sum += x;
    if(l == r) return ;
    int mid = (l+r)>>1;
    if(mid >= num) update(tree[rt].l,num,l,mid,x);
    else update(tree[rt].r,num,mid+1,r,x);
}
int query(int k,int l,int r)
{
    if(l == r) return l;
    int d = 0, mid = (l+r)>>1;
    for(int i = 1; i <= totx; i++) d -= tree[tree[X[i]].l].sum;
    for(int i = 1; i <= toty; i++) d += tree[tree[Y[i]].l].sum;
    if(d >= k){
        for(int i = 1; i <= totx; i++) X[i] = tree[X[i]].l;
        for(int i = 1; i <= toty; i++) Y[i] = tree[Y[i]].l;
        return query(k,l,mid);
    }
    else{
        for(int i = 1; i <= totx; i++) X[i] = tree[X[i]].r;
        for(int i = 1; i <= toty; i++) Y[i] = tree[Y[i]].r;
        return query(k-d,mid+1,r);
    }
}
int main()
{
    int n, m;
    n = read(); m = read();
    init();
    for(int i = 1; i <= n; i++){
        a[i] = read();
        b[++cnt] = a[i];
    }
    for(int i = 1; i <= m; i++){
        scanf("%s",s);
        q[i].l = read(); q[i].r = read();
        if(s[0] == 'Q') q[i].k = read();
        else b[++cnt] = q[i].r, q[i].k = 0;
    }
    sort(b+1,b+cnt+1);
    cnt = unique(b+1,b+cnt+1)-b-1;
    for(int i = 1; i <= n; i++){
        a[i] = lower_bound(b+1,b+cnt+1,a[i])-b;
        for(int j = i; j <= n; j += lowbit(j)){
            update(T[j],a[i],1,cnt,1);
        }
    }
    for(int i = 1; i <= m; i++){
        if(q[i].k){
            totx = toty = 0;
            for(int j = q[i].l-1; j; j -= lowbit(j)) X[++totx] = T[j];
            for(int j = q[i].r; j; j -= lowbit(j)) Y[++toty] = T[j];
            printf("%d\n",b[query(q[i].k,1,cnt)]);
        }
        else{
            for(int j = q[i].l; j <= n; j += lowbit(j)){
                update(T[j],a[q[i].l],1,cnt,-1);
            }
            q[i].r = lower_bound(b+1,b+cnt+1,q[i].r)-b;
            for(int j = q[i].l; j <= n; j += lowbit(j)){
                update(T[j],q[i].r,1,cnt,1);
            }
            a[q[i].l] = q[i].r;
        }
    }
    return 0;
}
```

#### 区间不同数个数

SPOJ - DQUERY

因为是主席树嘛，所以肯定要建立n 棵线段树，每个线段树是以每个位置的数为根，比如说该建立第i 个线段树了，如果这个数字之前没有出现过，那么我们直接以位置为划分依据，在线段树上包含这个位置的加1即可，表示这个区间上又多了一种数。

但是如果这个数字出现过了，我们先求出上一个同样数在哪里出现，我们就在第i 个线段树上以那个位置为划分依据给它减去1，在在第i 个线段树上 包含位置的i 的区间加1，这样我们就保证了 区间中数字不重复，只保留最后一个。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 3e4 + 5;
int T[maxn];
int times;
map<int,int> mp;
struct node{ int l, r, sum; } tree[maxn*40];
inline int read()
{
    int s = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ s = s*10+ch-'0'; ch = getchar(); }
    return s*f;
}
void init()
{
    T[0] = 0;
    tree[0].l = tree[0].r = tree[0].sum = 0;
}
void update(int &rt,int pos,int l,int r,int num)
{
    tree[++times] = tree[rt]; rt = times;
    tree[rt].sum += num;
    if(l == r) return ;
    int mid = (l+r)>>1;
    if(pos <= mid) update(tree[rt].l,pos,l,mid,num);
    else update(tree[rt].r,pos,mid+1,r,num);
}
int query(int t,int L,int l,int r)
{
    if(l >= L) return tree[t].sum;
    int mid = (l+r)>>1;
    if(L <= mid) return query(tree[t].l,L,l,mid)+tree[tree[t].r].sum;
    else return query(tree[t].r,L,mid+1,r);
}
int main()
{
    int n, m, x, tmp, y;
    n = read();
    init();
    for(int i = 1; i <= n; i++){
        x = read();
        if(!mp[x]) update(T[i]=T[i-1],i,1,n,1);
        else{
            update(tmp=T[i-1],mp[x],1,n,-1);
            update(T[i]=tmp,i,1,n,1);
        }
        mp[x] = i;
    }
    m = read();
    for(int i = 1; i <= m; i++){
        x = read(); y = read();
        printf("%d\n",query(T[y],x,1,n));
    }
    return 0;
}
```

#### 带修改的主席树

主席树+永久化标记

给定长度为n的数组，有四种操作：C l r d把[l, r]内的元素全部加上d并把时间计数器加1，Q l r查询[l, r]内元素的和，H l r t查询t时刻[l, r]内元素的和，B t返回时刻t(保证只向前而不向后跳)

HDU4348 To the moon

```c++
#include<cstdio>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
int a[maxn], T[maxn];
int n, m, times, t;
char s[5];
struct node{ int l, r; ll sum, add; } tree[maxn*50];
inline int read()
{
    int s = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ s = s*10+ch-'0'; ch = getchar(); }
    return s*f;
}
void init()
{
    T[0] = t = times = 0;
    tree[0].l = tree[0].r = tree[0].sum = tree[0].add = 0;
}
void build(int &rt,int l,int r)
{
    tree[++times] = tree[rt]; rt = times;
    if(l == r){ tree[rt].sum = a[l]; return ; }
    int mid = (l+r)>>1;
    build(tree[rt].l,l,mid);
    build(tree[rt].r,mid+1,r);
    tree[rt].sum = tree[tree[rt].l].sum+tree[tree[rt].r].sum;
}
ll query(int t,int L,int R,int l,int r,ll v)
{
    if(l >= L && r <= R) return tree[t].sum+(R-L+1)*v;
    int mid = (l+r)>>1;
    if(R <= mid) return query(tree[t].l,L,R,l,mid,v+tree[t].add);
    else if(L > mid) return query(tree[t].r,L,R,mid+1,r,v+tree[t].add);
    else return query(tree[t].l,L,mid,l,mid,v+tree[t].add)+query(tree[t].r,mid+1,R,mid+1,r,v+tree[t].add);
}
void update(int &rt,int L,int R,int l,int r,ll v)
{
    tree[++times] = tree[rt]; rt = times;
    tree[rt].sum += (R-L+1)*v;
    if(l == L && r == R){ tree[rt].add += v; return ; }
    int mid = (l+r)>>1;
    if(R <= mid) update(tree[rt].l,L,R,l,mid,v);
    else if(L > mid) update(tree[rt].r,L,R,mid+1,r,v);
    else update(tree[rt].l,L,mid,l,mid,v),update(tree[rt].r,mid+1,R,mid+1,r,v);
}
int main()
{
    while(scanf("%d%d",&n,&m) != EOF){
        init();
        for(int i = 1; i <= n; i++) a[i] = read();
        build(T[0],1,n);
        for(int i = 1,x,y,k; i <= m; i++){
            scanf("%s",s);
            if(s[0] == 'Q'){
                x = read(); y = read();
                printf("%lld\n",query(T[t],x,y,1,n,0));
            }
            else if(s[0] == 'C'){
                x = read(); y = read(); k = read();
                t++;
                update(T[t]=T[t-1],x,y,1,n,k);
            }
            else if(s[0] == 'H'){
                x = read(); y = read(); k = read();
                printf("%lld\n",query(T[k],x,y,1,n,0));
            }
            else t = read();
        }
    }
    return 0;
}
```

### 并查集

#### 普通并查集

```c++
#include<cstdio>
#include<algorithm>
using namespace std;
int prt[1010];
int getpa(int x){ return prt[x] == x ? x : prt[x] = getpa(prt[x]); }
int main()
{
    int n, m, a, b, ans;
    while(scanf("%d",&n) && n){
        scanf("%d",&m);
        ans = 0;
        for(int i = 1; i <= n; i++) prt[i] = i;
        for(int i = 1; i <= m; i++){
            scanf("%d%d",&a,&b);
            if(getpa(a) != getpa(b)){
                prt[getpa(max(a,b))] = getpa(min(a,b));
            }
        }
        for(int i = 1; i <= n; i++){
            if(getpa(i) == i) ans++;
        }
        printf("%d\n",ans-1);
    }
    return 0;
}

```

#### 加权并查集

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 3e4 + 5;
char s[5];
int prt[maxn], d[maxn], siz[maxn];
int get(int x)
{
    if(x == prt[x]) return x;
    int root = get(prt[x]);
    d[x] += d[prt[x]];
    return prt[x] = root;
}
void Merge(int x,int y)
{
    x = get(x); y = get(y);
    prt[x] = y; d[x] += siz[y];
    siz[y] += siz[x];
}
int main()
{
    int n = 3e4, m, x, y;
    scanf("%d",&m);
    for(int i = 1; i <= n; i++) prt[i] = i, siz[i] = 1;
    while(m--){
        scanf("%s%d",s+1,&x);
        if(s[1] == 'M'){
            scanf("%d",&y);
            Merge(x,y);
        }
        else{
            get(x);
            printf("%d\n",d[x]);
        }
    }
    return 0;
}
```

### dsu on tree

cf600 E

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
int tot, mx;
ll ans[maxn], sum[maxn];
int a[maxn], siz[maxn], son[maxn], vis[maxn], cnt[maxn];
int ver[maxn*2], Next[maxn*2], head[maxn];
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
void dfs1(int u,int ff)
{
    siz[u] = 1;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff) continue;
        dfs1(v,u);
        siz[u] += siz[v];
        if(siz[v] > siz[son[u]]) son[u] = v;
    }
}
void calc(int u,int ff,int op)
{
    sum[cnt[a[u]]] -= a[u];
    cnt[a[u]] += op;
    sum[cnt[a[u]]] += a[u];
    if(sum[mx+1]) mx++;
    else if(!sum[mx] && mx) mx--;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff || vis[v]) continue;
        calc(v,u,op);
    }
}
void dfs2(int u,int ff,int flag)
{
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff || v == son[u]) continue;
        dfs2(v,u,0);
    }
    if(son[u]) dfs2(son[u],u,1), vis[son[u]] = 1;
    calc(u,ff,1); vis[son[u]] = 0;
    ans[u] = sum[mx];
    if(!flag) calc(u,ff,-1);
}
int main()
{
    int n, x, y;
    scanf("%d",&n);
    for(int i = 1; i <= n; i++) scanf("%d",&a[i]);
    for(int i = 1; i < n; i++){
        scanf("%d%d",&x,&y);
        Add(x,y); Add(y,x);
    }
    dfs1(1,0);
    dfs2(1,0,0);
    for(int i = 1; i <= n; i++) printf("%lld ",ans[i]);
    return 0;
}
```

### CDQ分治

BZOJ3262 陌上花开

三维偏序

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 5;
int ans[maxn], c[maxn];
int tot, n, m;
struct node{ int a, b, c, cnt, ans; } q[maxn], p[maxn], tmp[maxn];
inline int read()
{
    int s = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ (s *= 10) += ch-'0'; ch = getchar(); }
    return s*f;
}
bool cmp1(node x,node y)
{
    if(x.a == y.a && x.b == y.b) return x.c < y.c;
    else if(x.a == y.a) return x.b < y.b;
    return x.a < y.a;
}
bool cmp2(node x,node y)
{
    return x.b == y.b ? x.c < y.c : x.b < y.b;
}
int lowbit(int x){ return x&(-x); }
void update(int k,int x)
{
    for(int i = k; i <= m; i += lowbit(i)) c[i] += x;
}
int query(int k)
{
    int res = 0;
    for(int i = k; i; i -= lowbit(i)) res += c[i];
    return res;
}
void cdq(int l,int r)
{
    if(l == r) return ;
    int mid = (l+r)>>1;
    cdq(l,mid); cdq(mid+1,r);
    int i = l, j = mid+1, tp = l;
    while(i <= mid || j <= r){
        if(j > r || (i <= mid && p[i].b <= p[j].b)) update(p[i].c,p[i].cnt),tmp[tp++] = p[i++];
        else p[j].ans += query(p[j].c), tmp[tp++] = p[j++];
    }
    for(j = l; j < i; j++) update(p[j].c,-p[j].cnt);
    for(int i = l; i <= r; i++) p[i] = tmp[i];
}
int main()
{
    n = read(); m = read();
    for(int i = 1; i <= n; i++){
        q[i].a = read(); q[i].b = read(); q[i].c = read();
    }
    sort(q+1,q+n+1,cmp1);
    for(int i = 1,j = 0; i <= n; i++){
        j++;
        if(q[i].a != q[i+1].a || q[i].b != q[i+1].b || q[i].c != q[i+1].c){
            p[++tot] = q[i]; p[tot].cnt = j;
            j = 0;
        }
    }
    cdq(1,tot);
    for(int i = 1; i <= tot; i++) ans[p[i].ans+p[i].cnt-1] += p[i].cnt;
    for(int i = 0; i < n; i++) printf("%d\n",ans[i]);
    return 0;
}

```

牛客 contest

n支队伍一共参加了三场比赛。
一支队伍x认为自己比另一支队伍y强当且仅当x在至少一场比赛中比y的排名高。
求有多少组(x,y)，使得x自己觉得比y强，y自己也觉得比x强。
(x, y), (y, x)算一组。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 5;
ll ans;
int c[maxn], n;
struct node{ int a, b, c, cnt; } q[maxn], p[maxn];
bool cmp(node q1,node q2)
{
    return q1.a < q2.a;
}
int lowbit(int x){ return x&(-x); }
void update(int k,int x)
{
    for(int i = k; i <= n; i += lowbit(i)) c[i] += x;
}
int query(int k)
{
    int res = 0;
    for(int i = k; i; i -= lowbit(i)) res += c[i];
    return res;
}
void cdq(int l,int r)
{
    if(l == r) return ;
    int mid = (l+r)>>1;
    cdq(l,mid); cdq(mid+1,r);
    int i = l, j = mid+1, k = l;
    while(i <= mid && j <= r){
        if(q[i].b < q[j].b) update(q[i].c,1), p[k++] = q[i++];
        else ans -= query(q[j].c), p[k++] = q[j++];
    }
    while(i <= mid){
        update(q[i].c,1);
        p[k++] = q[i++];
    }
    while(j <= r){
        ans -= query(q[j].c);
        p[k++] = q[j++];
    }
    for(j = l; j <= mid; j++) update(q[j].c,-1);
    for(j = l; j <= r; j++) q[j] = p[j];
}
int main()
{
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%d%d%d",&q[i].a,&q[i].b,&q[i].c);
    }
    sort(q+1,q+n+1,cmp);
    ans = (ll)n*(n-1)/2;
    cdq(1,n);
    printf("%lld\n",ans);
    return 0;
}
```

牛客 练习赛59F

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
int cnt;
ll bit[maxn], f[maxn];
int a[maxn], b[maxn], c[maxn];
struct qnode{ int x, h, c, id; } q[maxn];
bool cmpx(qnode q1,qnode q2)
{
    return q1.x < q2.x;
}
bool cmph(qnode q1,qnode q2)
{
    return q1.h < q2.h;
}
int lowbit(int x){ return x&(-x); }
void update(int k,ll x)
{
    for(int i = k; i <= cnt; i += lowbit(i)) bit[i] = max(bit[i],x);
}
ll query(int k)
{
    ll res = 0;
    for(int i = k; i; i -= lowbit(i)) res = max(res,bit[i]);
    return res;
}
void cdq(int l,int r)
{
    if(l == r){
        f[q[l].id] = max(f[q[l].id],(ll)q[l].c);
        return ;
    }
    int mid = (l+r)>>1;
    sort(q+l,q+r+1,cmph);
    cdq(l,mid);
    sort(q+l,q+mid+1,cmpx); sort(q+mid+1,q+r+1,cmpx);
    //h[i] < h[j] a[i] < a[j]
    //h[j]-h[i] >= a[j]-a[i] h[j]-a[j] >= h[i]-a[i]
    cnt = 0;
    for(int i = l; i <= mid; i++) c[++cnt] = q[i].h-q[i].x;
    sort(c+1,c+cnt+1);
    cnt = unique(c+1,c+cnt+1)-c-1;
    for(int j = mid+1, i = l; j <= r; j++){
        while(i <= mid && q[i].x <= q[j].x){
            int p = lower_bound(c+1,c+cnt+1,q[i].h-q[i].x)-c;
            update(p,f[q[i].id]);
            i++;
        }
        int p = upper_bound(c+1,c+cnt+1,q[j].h-q[j].x)-c-1;
        f[q[j].id] = max(f[q[j].id],query(p)+q[j].c);
    }
    for(int i = 1; i <= cnt; i++) bit[i] = 0;
    //h[i] < h[j] a[i] > a[j]
    //h[j]-h[i] >= a[i]-a[j] h[j]+a[j] >= h[i]+a[i]
    cnt = 0;
    for(int i = l; i <= mid; i++) c[++cnt] = q[i].h+q[i].x;
    sort(c+1,c+cnt+1);
    cnt = unique(c+1,c+cnt+1)-c-1;
    for(int j = r, i = mid; j >= mid+1; j--){
        while(i >= l && q[i].x >= q[j].x){
            int p = lower_bound(c+1,c+cnt+1,q[i].h+q[i].x)-c;
            update(p,f[q[i].id]);
            i--;
        }
        int p = upper_bound(c+1,c+cnt+1,q[j].h+q[j].x)-c-1;
        f[q[j].id] = max(f[q[j].id],query(p)+q[j].c);
    }
    for(int i = 1; i <= cnt; i++) bit[i] = 0;
    cdq(mid+1,r);
}
int main()
{
	int n, m;
	scanf("%d%d",&n,&m);
	for(int i = 1; i <= m; i++){
        scanf("%d",&a[i]);
	}
	for(int i = 1; i <= m; i++){
        scanf("%d",&b[i]);
	}
	for(int i = 1; i <= n; i++){
        int t, p, c;
        scanf("%d%d%d",&t,&p,&c);
        q[i] = (qnode){a[p],b[p]+t,c,i};
	}
	cdq(1,n);
	printf("%lld\n",*max_element(f+1,f+n+1));
	return 0;
}
```

### 整体二分

#### 带修改的区间第k大

ZOJ2112 Dynamic Rankings

```c++
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn = 1e5 + 5;
char s[5];
int inf = 1e9, ans[maxn], c[maxn], n, m, tot, a[maxn];
struct node{ int op, x, y, z, id; } q[maxn*2], lq[maxn*2], rq[maxn*2];
int lowbit(int x){ return x&(-x); }
void update(int k,int x)
{
    for(int i = k; i <= n; i += lowbit(i)) c[i] += x;
}
int query(int k)
{
    int res = 0;
    for(int i = k; i; i -= lowbit(i)) res += c[i];
    return res;
}
void solve(int l,int r,int L,int R)
{
    if(L > R) return ;
    if(l == r){
        for(int i = L; i <= R; i++){
            if(q[i].op == 3) ans[q[i].id] = l;
        }
        return ;
    }
    int mid = (l+r)>>1, cnt1 = 0, cnt2 = 0;
    for(int i = L; i <= R; i++){
        if(q[i].op == 1){
            if(q[i].y <= mid) update(q[i].x,1), lq[++cnt1] = q[i];
            else rq[++cnt2] = q[i];
        }
        else if(q[i].op == 2){
            if(q[i].y <= mid) update(q[i].x,-1), lq[++cnt1] = q[i];
            else rq[++cnt2] = q[i];
        }
        else{
            int tmp = query(q[i].y)-query(q[i].x-1);
            if(tmp >= q[i].z) lq[++cnt1] = q[i];
            else q[i].z -= tmp, rq[++cnt2] = q[i];
        }
    }
    for(int i = R; i >= L; i--){
        if(q[i].op == 1 && q[i].y <= mid) update(q[i].x,-1);
        else if(q[i].op == 2 && q[i].y <= mid) update(q[i].x,1);
    }
    for(int i = 1; i <= cnt1; i++) q[L+i-1] = lq[i];
    for(int i = 1; i <= cnt2; i++) q[L+cnt1+i-1] = rq[i];
    solve(l,mid,L,L+cnt1-1);
    solve(mid+1,r,L+cnt1,R);
}
int main()
{
    int ansid, t;
    scanf("%d",&t);
    while(t--){
        ansid = 0; tot = 0;
        memset(c,0,sizeof(c));
        scanf("%d%d",&n,&m);
        for(int i = 1; i <= n; i++){
            scanf("%d",&a[i]);
            q[++tot].op = 1; q[tot].x = i, q[tot].y = a[i];
        }
        for(int i = 1,l,r,k; i <= m; i++){
            scanf("%s",s);
            if(s[0] == 'Q'){
                scanf("%d%d%d",&l,&r,&k);
                q[++tot].op = 3; q[tot].x = l; q[tot].y = r; q[tot].z = k;
                q[tot].id = ++ansid;
            }
            else{
                scanf("%d%d",&l,&r);
                q[++tot].op = 2; q[tot].x = l; q[tot].y = a[l];
                q[++tot].op = 1; q[tot].x = l; q[tot].y = r;
                a[l] = r;
            }
        }
        solve(-inf,inf,1,tot);
        for(int i = 1; i <= ansid; i++) printf("%d\n",ans[i]);
    }
    return 0;
}
```

### 树链剖分

#### 点权

一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。完成一些操作： 

1. CHANGE u t : 把结点u的权值改为t

2. QMAX u v: 询问从点u到点v的路径上的节点的最大权值 I

3. QSUM u v: 询问从点u到点v的路径上的节点的权值和 注意：从点u到点v的路径上的节点包括u和v本身

BZOJ1036 树的统计Count

```c++
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 3e4 + 5;
struct node{ int l, r, maxx, sum; } tree[maxn*4] ;
int ver[maxn*2], Next[maxn*2], head[maxn], num[maxn];
int fa[maxn], son[maxn], siz[maxn], top[maxn], dep[maxn], seg[maxn], rev[maxn];
char s[20];
int tot, maxx, sum;
inline int read()
{
    int s = 0, sign = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') sign = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){s = s*10+ch-'0'; ch = getchar(); }
    return s*sign;
}
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
void dfs1(int u,int ff)
{
    siz[u] = 1;
    fa[u] = ff;
    dep[u] = dep[ff]+1;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff) continue;
        dfs1(v,u);
        siz[u] += siz[v];
        if(siz[v] > siz[son[u]]) son[u] = v;
    }
}
void dfs2(int u,int ff)
{
    if(son[u]){
        seg[son[u]] = ++seg[0];
        top[son[u]] = top[u];
        rev[seg[0]] = son[u];
        dfs2(son[u],u);
    }
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(top[v]) continue;
        seg[v] = ++seg[0];
        top[v] = v;
        rev[seg[0]] = v;
        dfs2(v,u);
    }
}
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r;
    if(l == r){
        tree[k].maxx = num[rev[l]];
        tree[k].sum = num[rev[l]];
        return ;
    }
    int mid = (l+r)>>1;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    tree[k].maxx = max(tree[k<<1].maxx,tree[k<<1|1].maxx);
    tree[k].sum = tree[k<<1].sum+tree[k<<1|1].sum;
}
void update(int k,int p,int v)
{
    if(tree[k].l == tree[k].r && tree[k].l == p){
        tree[k].maxx = v; tree[k].sum = v;
        return ;
    }
    int mid = (tree[k].l+tree[k].r)/2;
    if(mid >= p) update(k<<1,p,v);
    else update(k<<1|1,p,v);
    tree[k].maxx = max(tree[k<<1].maxx,tree[k<<1|1].maxx);
    tree[k].sum = tree[k<<1].sum+tree[k<<1|1].sum;
}
void query(int k,int l,int r)
{
    if(tree[k].l > r || tree[k].r < l) return ;
    if(tree[k].l >= l && tree[k].r <= r){
        maxx = max(maxx,tree[k].maxx);
        sum += tree[k].sum;
        return ;
    }
    query(k<<1,l,r);
    query(k<<1|1,l,r);
}
void ask(int x,int y)
{
    int fx = top[x], fy = top[y];
    while(fx != fy){
        if(dep[fx] < dep[fy]) swap(x,y), swap(fx,fy);
        query(1,seg[fx],seg[x]);
        x = fa[fx]; fx = top[x];
    }
    if(dep[x] > dep[y]) swap(x,y);
    query(1,seg[x],seg[y]);
}
int main()
{
    int n = read();
    for(int i = 1,x,y; i < n; i++){
        x = read(); y = read();
        Add(x,y); Add(y,x);
    }
    for(int i = 1; i <= n; i++){
        num[i] = read();
    }
    dfs1(1,0);
    seg[0] = seg[1] = top[1] = rev[1] = 1;
    dfs2(1,0);
    build(1,1,seg[0]);
    int m = read();
    for(int i = 1,x,y; i <= m; i++){
        scanf("%s",s+1);
        x = read(); y = read();
        if(s[1] == 'C') update(1,seg[x],y);
        else{
            sum = 0; maxx = -3000000;
            ask(x,y);
            if(s[2] == 'M') printf("%d\n",maxx);
            else printf("%d\n",sum);
        }
    }
    return 0;
}
```

BZOJ4034 树上操作

有一棵点数为 N 的树，以点 1 为根，且树点有边权。然后有 M 个

操作，分为三种：

操作 1 ：把某个节点 x 的点权增加 a 。

操作 2 ：把某个节点 x 为根的子树中所有点的点权都增加 a 。

操作 3 ：询问某个节点 x 到根的路径中所有点的点权和。

对于2操作 以x为根的所有子节点的区间为seg[x],seg[x]+siz[x]-1，该点在线段树的位置到该点位置+以该点为根的子节点个数，因为树链剖分时子节点与根的位置是相连的

```c++
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
struct node{ int l, r; ll sum, val; } tree[maxn*4];
int ver[maxn*2], Next[maxn*2], head[maxn];
int fa[maxn], son[maxn], top[maxn], siz[maxn], dep[maxn], seg[maxn], rev[maxn];
int tot;
ll sum, num[maxn];
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
inline int read()
{
    int s = 0, sign = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') sign = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ s = s*10+ch-'0'; ch = getchar(); }
    return s*sign;
}
void dfs1(int u,int f)
{
    fa[u] = f;
    dep[u] = dep[f]+1;
    siz[u] = 1;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == f) continue;
        dfs1(v,u);
        siz[u] += siz[v];
        if(siz[v] > siz[son[u]]) son[u] = v;
    }
}
void dfs2(int u,int f)
{
    if(son[u]){
        seg[son[u]] = ++seg[0];
        top[son[u]] = top[u];
        rev[seg[0]] = son[u];
        dfs2(son[u],u);
    }
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(top[v]) continue;
        seg[v] = ++seg[0];
        top[v] = v;
        rev[seg[0]] = v;
        dfs2(v,u);
    }
}
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r; tree[k].val = 0;
    if(l == r){ tree[k].sum = num[rev[l]]; return ; }
    int mid = (l+r)>>1;
    build(k<<1,l,mid);
    build(k<<1|1,mid+1,r);
    tree[k].sum = tree[k<<1].sum+tree[k<<1|1].sum;
}
void change(int k,ll v)
{
    tree[k].val += v;
    tree[k].sum += (tree[k].r-tree[k].l+1)*v;
}
void pushdown(int k)
{
    if(tree[k].val == 0) return ;
    change(k<<1,tree[k].val);
    change(k<<1|1,tree[k].val);
    tree[k].val = 0;
}
void modify(int k,int l,int r,ll v)
{
    if(tree[k].l > r || tree[k].r < l) return ;
    if(tree[k].l >= l && tree[k].r <= r) return change(k,v);
    pushdown(k);
    modify(k<<1,l,r,v);
    modify(k<<1|1,l,r,v);
    tree[k].sum = tree[k<<1].sum+tree[k<<1|1].sum;
}
void query(int k,int l,int r)
{
    if(tree[k].l > r || tree[k].r < l) return ;
    if(tree[k].l >= l && tree[k].r <= r){
        sum += tree[k].sum; return ;
    }
    pushdown(k);
    query(k<<1,l,r);
    query(k<<1|1,l,r);
}
void ask(int x,int y)
{
    int fx = top[x], fy = top[y];
    while(fx != fy){
        if(dep[fx] < dep[fy]) swap(x,y), swap(fx,fy);
        query(1,seg[fx],seg[x]);
        x = fa[fx]; fx = top[x];
    }
    if(dep[x] > dep[y]) swap(x,y);
    query(1,seg[x],seg[y]);
}
int main()
{
    int n = read(), m = read();
    for(int i = 1; i <= n; i++) num[i] = read();
    for(int i = 1,x,y; i < n; i++){
        x = read(); y = read();
        Add(x,y); Add(y,x);
    }
    dfs1(1,0);
    seg[0] = seg[1] = top[1] = rev[1] = 1;
    dfs2(1,0);
    build(1,1,seg[0]);
    for(int i = 1,op,x,y; i <= m; i++){
        op  = read();
        if(op == 3){
            x = read();
            sum = 0;
            ask(1,x);
            printf("%lld\n",sum);
        }
        else{
            x = read(); y = read();
            if(op == 1) modify(1,seg[x],seg[x],(ll)y);
            else modify(1,seg[x],seg[x]+siz[x]-1,(ll)y);
        }
    }
    return 0;
}
```

#### 妙用

采蘑菇的克拉莉丝(2020 wannafly camp day2 f)

树链剖分，考虑只枚举和父亲、重儿子的边，还差所有轻儿子的贡献。于是修改的时候，往根跳，在轻重链交替的时候往轻边父亲打标记即可。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e6 + 5;
int tot, times, n;
ll c[maxn], ans[maxn];
int ver[maxn*2], Next[maxn*2], edge[maxn*2], head[maxn];
int fa[maxn], siz[maxn], son[maxn], cost[maxn];
int in[maxn], out[maxn], top[maxn];
void Add(int x,int y,int z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
void dfs1(int u,int f)
{
    fa[u] = f; siz[u] = 1;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == f) continue;
        dfs1(v,u);
        cost[v] = edge[i];
        siz[u] += siz[v];
        if(siz[v] > siz[son[u]]) son[u] = v;
    }
}
void dfs2(int u,int f)
{
    in[u] = ++times;
    if(son[u]){
        top[son[u]] = top[u];
        dfs2(son[u],u);
    }
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(top[v]) continue;
        top[v] = v;
        dfs2(v,u);
    }
    out[u] = times;
}
int lowbit(int x){ return x&(-x); }
void update(int k,int x)
{
    for(int i = k; i <= n; i += lowbit(i)) c[i] += x;
}
ll query(int k)
{
    ll res = 0;
    for(int i = k; i; i -= lowbit(i)) res += c[i];
    return res;
}
int main()
{
    int x, y, z;
    scanf("%d",&n);
    for(int i = 1; i < n; i++){
        scanf("%d%d%d",&x,&y,&z);
        Add(x,y,z); Add(y,x,z);
    }
    dfs1(1,0); top[1] = 1; dfs2(1,0);
    int m, op, root = 1;
    scanf("%d",&m);
    while(m--){
        scanf("%d%d",&op,&x);
        if(op == 1){
            scanf("%d",&y);
            update(in[x],y);
            while(1){
                int tmp = fa[x];
                if(!tmp) break;
                if(son[tmp] != x) ans[tmp] += (ll)y*cost[x];
                x = top[tmp];
            }
        }
        else{
            root = x;
        }
        ll ans1 = 0;
        if(son[root]) ans1 = (ll)cost[son[root]]*(query(out[son[root]])-query(in[son[root]]-1));
        ll ans2 = (ll)cost[root]*(query(n)-(query(out[root])-query(in[root]-1)));
        printf("%lld\n",ans1+ans2+ans[root]);
    }
    return 0;
}

```

### 字典树

#### 01字典树

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 4e6;
struct Trie
{
    int root, p, Next[maxn][2];
    void init(){
        root = p = 0;
        memset(Next,-1,sizeof(Next));
    }
    int newnode(){ return ++p; }
    void Insert(ll val){
        int now = root;
        for(int i = 32; i >= 0; i--){
            int f = 0;
            if((1ll<<i) & val) f = 1;
            if(Next[now][f] == -1) Next[now][f] = newnode();
            now = Next[now][f];
        }
    }
    ll query(ll val){
        ll res = 0; int now = root;
        for(int i = 32; i >= 0; i--){
            int f = 0;
            if((1ll<<i) & val) f = 1;
            if(Next[now][f^1] != -1){
                res += ((ll)(f^1)<<i);
                now = Next[now][f^1];
            }
            else{
                now = Next[now][f];
                res += ((ll)f<<i);
            }
        }
        return res;
    }
} trie;
int main()
{
    int t, n, m; scanf("%d",&t);
    ll x;
    for(int mycase = 1; mycase <= t; mycase++){
        scanf("%d%d",&n,&m);
        trie.init();
        for(int i = 1; i <= n; i++){
            scanf("%I64d",&x);
            trie.Insert(x);
        }
        printf("Case #%d:\n",mycase);
        for(int i = 1; i <= m; i++){
            scanf("%I64d",&x);
            printf("%I64d\n",trie.query(x));
        }
    }
    return 0;
}
```

#### 字母字典树

牛客 假的字符串

给定n个字符串，互不相等，你可以任意指定字符之间的大小关系（即重定义字典序），求有多少个串可能成为字典序最小的串，并输出它们  

字典树+拓扑排序

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 3e5 + 5;
int trie[maxn][26], mp[30][30], in[30];
string str[30005];
char s[maxn];
bool ed[maxn], vis[30005];
int tot = 1, flag, tag;
queue<int> q;
void Insert(char *s)
{
    int len = strlen(s), p = 1;
    for(int i = 0; i < len; i++){
        int ch = s[i]-'a';
        if(!trie[p][ch]) trie[p][ch] = ++tot;
        p = trie[p][ch];
    }
    ed[p] = true;
}
int topsort()
{
    int cnt = 0;
    while(!q.empty()) q.pop();
    for(int i = 0; i < 26; i++){
        if(!in[i]) q.push(i);
    }
    while(!q.empty()){
        int x = q.front(); q.pop();
        cnt++;
        for(int i = 0; i < 26; i++){
            if(mp[x][i] == tag){
                if(--in[i] == 0) q.push(i);
            }
        }
    }
    if(cnt == 26) return 1;
    return 0;
}
int check(string &s)
{
    memset(in,0,sizeof(in));
    int p = 1; tag++;
    for(int i = 0; i < (int)s.length(); i++){
        int ch = s[i]-'a';
        if(ed[p]) return 0;
        for(int j = 0; j < 26; j++){
            if(j == ch) continue;
            if(trie[p][j] && mp[ch][j] != tag){
                mp[ch][j] = tag; in[j]++;
            }
        }
        p = trie[p][ch];
    }
    return topsort();
}
int main()
{
    int n, ans;
    scanf("%d",&n); ans = n;
    for(int i = 1; i <= n; i++){
        scanf("%s",s);
        flag = 1; str[i] = s;
        Insert(s);
    }
    for(int i = 1; i <= n; i++){
        if(!check(str[i])) vis[i] = true, ans--;
    }
    printf("%d\n",ans);
    for(int i = 1; i <= n; i++){
        if(!vis[i]) cout<<str[i]<<endl;
    }
    return 0;
}

```

#### 可持久化字典树

BZOJ3261 最大异或和

 给定一个非负整数序列{a}，初始长度为N。

有M个操作，有以下两种操作类型：

1、Ax：添加操作，表示在序列末尾添加一个数x，序列的长度N+1。

2、Qlrx：询问操作，你需要找到一个位置p，满足l<=p<=r，使得：

a[p] xor a[p+1] xor ... xor a[N] xor x 最大，输出最大是多少。

```c++
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 6e5 + 5;
int a[maxn], trie[maxn*25][2], T[maxn], latest[maxn*25];
int tot, n, m, x, y, z;
char s[5];
void update(int i,int k,int t1,int t2)
{
    if(k < 0){ latest[t2] = i; return ; }
    int c = (a[i]>>k)&1;
    if(t1) trie[t2][c^1] = trie[t1][c^1];
    trie[t2][c] = ++tot;
    update(i,k-1,trie[t1][c],trie[t2][c]);
    latest[t2] = max(latest[trie[t2][0]],latest[trie[t2][1]]);
}
int query(int now,int num,int k,int limit)
{
    if(k < 0) return a[latest[now]]^num;
    int c = (num>>k)&1;
    if(latest[trie[now][c^1]] >= limit)
        return query(trie[now][c^1],num,k-1,limit);
    else
        return query(trie[now][c],num,k-1,limit);
}
int main()
{
    latest[0] = -1;
    T[0] = ++tot;
    update(0,24,0,T[0]);
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++){
        scanf("%d",&x);
        a[i] = a[i-1]^x;
        T[i] = ++tot;
        update(i,24,T[i-1],T[i]);
    }
    for(int i = 1; i <= m; i++){
        scanf("%s",s);
        if(s[0] == 'A'){
            scanf("%d",&x);
            T[++n] = ++tot;
            a[n] = a[n-1]^x;
            update(n,24,T[n-1],T[n]);
        }
        else{
            scanf("%d%d%d",&x,&y,&z);
            printf("%d\n",query(T[y-1],a[n]^z,24,x-1));
        }
    }
    return 0;
}
```

### 分块

洛谷p2801 教主的魔法

两种操作 M操作 对区间进行加操作 A操作 询问区间大于c的有多少个

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e6 + 5;
char s[5];
int a[maxn], b[maxn];
int L[maxn], R[maxn], belong[maxn], lazy[maxn];
int block, num;
inline int read()
{
    int s = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ (s *= 10) += ch-'0'; ch = getchar(); }
    return s*f;
}
int query(int l,int r,int x)
{
    int ans = 0;
    int p = belong[l], q = belong[r];
    if(p == q){
        for(int i = l; i <= r; i++){
            if(a[i]+lazy[p] >= x) ans++;
        }
    }
    else{
        int tmp;
        for(int i = p+1; i <= q-1; i++){
            tmp = lower_bound(b+L[i],b+R[i]+1,x-lazy[i])-b;
            ans += R[i]-tmp+1;
        }
        for(int i = l; i <= R[p]; i++){
            if(a[i]+lazy[p] >= x) ans++;
        }
        for(int i = L[q]; i <= r; i++){
            if(a[i]+lazy[q] >= x) ans++;
        }
    }
    return ans;
}
void update(int l,int r,int x)
{
    int p = belong[l], q = belong[r];
    if(p == q){
        for(int i = l; i <= r; i++) a[i] += x;
        for(int i = L[p]; i <= R[p]; i++) b[i] = a[i];
        sort(b+L[p],b+R[p]+1);
    }
    else{
        for(int i = p+1; i <= q-1; i++) lazy[i] += x;
        for(int i = l; i <= R[p]; i++) a[i] += x;
        for(int i = L[p]; i <= R[p]; i++) b[i] = a[i];
        sort(b+L[p],b+R[p]+1);
        for(int i = L[q]; i <= r; i++) a[i] += x;
        for(int i = L[q]; i <= R[q]; i++) b[i] = a[i];
        sort(b+L[q],b+R[q]+1);
    }
}
int main()
{
    int n, m, l, r, x;
    n = read(); m = read();
    for(int i = 1; i <= n; i++){
        a[i] = read();
        b[i] = a[i];
    }
    block = (int)sqrt(n*1.0);
    num = n/block;
    for(int i = 1; i <= num; i++){
        L[i] = (i-1)*block+1;
        R[i] = i*block;
    }
    if(R[num] < n) num++, L[num] = R[num-1]+1, R[num] = n;
    for(int i = 1; i <= num; i++){
        for(int j = L[i]; j <= R[i]; j++){
            belong[j] = i;
        }
        sort(b+L[i],b+R[i]+1);
    }
    for(int i = 1; i <= m; i++){
        scanf("%s",s);
        l = read(); r = read(); x = read();
        if(s[0] == 'A'){
            printf("%d\n",query(l,r,x));
        }
        else{
            update(l,r,x);
        }
    }
    return 0;
}
```

### 莫队算法

#### 普通莫队

block = n/(sqrt(m)) 或许最优

HDU6534 

求区间内两点绝对值之差小于等与k的点对有多少

对序列中的所有元素以及这些元素+K，-K后的值进行离散化。

然后使用莫队算法，在莫队算法的端点移动过程中，新加入一个元素x的过程中，将其插入树状数组，查询[x-K,x+K]范围的元素数即可。删除一个元素的过程与其类似。

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn = 27005;
int a[maxn], b[maxn*3], c[maxn*3], ans[maxn], lef[maxn], rig[maxn];
int tot, block, n, m, k, tmp, cnt;
struct node{ int l, r, id; } q[maxn];
inline int read()
{
    int s = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ s = s*10+ch-'0'; ch = getchar(); }
    return s*f;
}
bool cmp(node q1,node q2)
{
    return q1.l/block == q2.l/block ? q1.r < q2.r : q1.l < q2.l;
}
int lowbit(int x){ return x&(-x); }
void update(int k,int x)
{
    for(int i = k; i <= cnt; i += lowbit(i)) c[i] += x;
}
int query(int k)
{
    int res = 0;
    for(int i = k; i; i -= lowbit(i)) res += c[i];
    return res;
}
void add(int x)
{
    tmp += query(rig[x])-query(lef[x]-1);
    update(a[x],1);
}
void del(int x)
{
    update(a[x],-1);
    tmp -= query(rig[x])-query(lef[x]-1);
}
int main()
{
    n = read(); m = read(); k = read();
    for(int i = 1; i <= n; i++){
        a[i] = read();
        b[++tot] = a[i]; b[++tot] = a[i]-k; b[++tot] = a[i]+k;
    }
    cnt = unique(b+1,b+tot+1)-b-1;
    sort(b+1,b+cnt+1);
    for(int i = 1; i <= n; i++){
        lef[i] = lower_bound(b+1,b+cnt+1,a[i]-k)-b;
        rig[i] = lower_bound(b+1,b+cnt+1,a[i]+k)-b;
        a[i] = lower_bound(b+1,b+cnt+1,a[i])-b;
    }
    for(int i = 1; i <= m; i++){
        q[i].l = read(); q[i].r = read();
        q[i].id = i;
    }
    block = sqrt(n);
    sort(q+1,q+m+1,cmp);
    int l = q[1].l, r = q[1].l-1, ql, qr;
    for(int i = 1; i <= m; i++){
        ql = q[i].l; qr = q[i].r;
        while(ql < l) add(--l);
        while(ql > l) del(l++);
        while(qr < r) del(r--);
        while(qr > r) add(++r);
        ans[q[i].id] = tmp;
    }
    for(int i = 1; i <= m; i++) printf("%d\n",ans[i]);
    return 0;
}
```

洛谷 P1972 [SDOI2009]HH的项链

求区间不同数个数

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e5 + 5;
int a[maxn], vis[maxn*2], ans[maxn];
int n, m, block, tmp;
struct node{ int l, r, id, belong; } q[maxn];
inline int read()
{
    int s = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ s = s*10+ch-'0'; ch = getchar(); }
    return s*f;
}
bool cmp(node q1,node q2)
{
    return q1.belong == q2.belong ? (q1.belong&1) ? q1.r < q2.r : q1.r > q2.r : q1.l < q2.l;
}
void add(int x){ tmp += (++vis[a[x]] == 1); }
void del(int x){ tmp -= (--vis[a[x]] == 0); }
int main()
{
    n = read();
    for(int i = 1; i <= n; i++) a[i] = read();
    m = read(); block = sqrt(n);
    for(int i = 1; i <= m; i++){
        q[i].l = read(); q[i].r = read();
        q[i].id = i; q[i].belong = q[i].l/block;
    }
    sort(q+1,q+m+1,cmp);
    int l = q[1].l, r = q[1].l-1, ql, qr;
    for(int i = 1; i <= m; i++){
        ql = q[i].l, qr = q[i].r;
        while(ql < l) add(--l);
        while(ql > l) del(l++);
        while(qr < r) del(r--);
        while(qr > r) add(++r);
        ans[q[i].id] = tmp;
    }
    for(int i = 1; i <= m; i++) printf("%d\n",ans[i]);
    return 0;
}
```

牛客 https://ac.nowcoder.com/acm/contest/992/I

n个不同的滑稽果中，每个滑稽果可取可不取，从所有方案数中选取一种，求选取的方案中滑稽果个数不超过m的概率。(对109+7取模)

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
const int mod = 1e9 + 7;
ll ans[maxn], jc[maxn], inv[maxn], inv2[maxn], invv[maxn];
int block;
struct node{ int l, r, id; } q[maxn];
bool cmp(node q1,node q2)
{
    if(q1.l/block == q2.l/block) return (q1.l/block)&1 ? q1.r < q2.r : q1.r > q2.r;
    return q1.l < q2.l;
}
ll qp(ll x,ll y)
{
    ll res = 1;
    while(y){
        if(y&1) res = res*x%mod;
        y >>= 1;
        x = x*x%mod;
    }
    return res;
}
void pre()
{
    inv2[0] = jc[0] = 1;
    for(int i = 1; i < maxn; i++) jc[i] = jc[i-1]*i%mod;
    inv[maxn-1] = qp(jc[maxn-1],mod-2);
    for(int i = maxn-1; i > 0; i--) inv[i-1] = inv[i]*i%mod;
    inv2[maxn-5] = qp(qp(2,maxn-5),mod-2);
    for(int i = maxn-6; i >= 1; i--) inv2[i] = (ll)inv2[i+1]*2%mod;
}
ll C(int n,int m)
{
    if(n < m) return 0;
    return jc[n]*inv[n-m]%mod*inv[m]%mod;
}
int main()
{
    int t, mx = 0;
    pre();
    scanf("%d",&t);
    for(int i = 1; i <= t; i++){
        scanf("%d%d",&q[i].r,&q[i].l);
        q[i].id = i;
        mx = max(mx,q[i].r);
    }
    block = sqrt(mx);
    sort(q+1,q+t+1,cmp);
    int l = 1, r = 1, ql, qr, tmp = 2;
    for(int i = 1; i <= t; i++){
        ql = q[i].l; qr = q[i].r;
        while(ql > l) tmp = (tmp+C(r,++l))%mod;
        while(ql < l) tmp = (tmp-C(r,l--)+mod)%mod;
        while(qr > r) tmp = (tmp*2-C(r++,l)+mod)%mod;
        while(qr < r) tmp = (tmp+C(--r,l))*inv2[1]%mod;
        ans[q[i].id] = tmp*inv2[r]%mod;
    }
    for(int i = 1; i <= t; i++) printf("%lld\n",ans[i]);
    return 0;
}
```



### 重构树

给你N个点的无向图 (1 <= N <= 15,000)，记为：1…N。
图中有M条边 (1 <= M <= 30,000) ，第j条边的长度为： d_j ( 1 < = d_j < = 1,000,000,000).

现在有 K个询问 (1 < = K < = 20,000)。
每个询问的格式是：A B，表示询问从A点走到B点的所有路径中，最长的边最小值是多少？

性质：1.是一个二叉树
           2.如果是按最小生成树建立的话是一个大根堆(important!                                                                                              3.任意两个点路径上边权的最大值为它们的LCA的点权                                                                                                    4.重构树中代表原树中的点的节点全是叶子节点，其余节点都代表了一条边的边权。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 3e4 + 5;
int n, m, q, idx, tot;
int a[maxn], fa[maxn][21], dep[maxn];
int prt[maxn], ver[maxn*4], Next[maxn*4], head[maxn];
struct node{ int u, v, w; } edge[maxn];
bool cmp(node q1,node q2){ return q1.w < q2.w; }
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
int getpa(int x){ return prt[x] == x ? x : prt[x] = getpa(prt[x]); }
void kruskal()
{
    sort(edge+1,edge+m+1,cmp);
    for(int i = 1; i <= n*2; i++) prt[i] = i;
    idx = n;
    for(int i = 1; i <= m; i++){
        int fx = getpa(edge[i].u), fy = getpa(edge[i].v);
        if(fx == fy) continue;
        prt[fx] = prt[fy] = ++idx;
        a[idx] = edge[i].w;
        Add(idx,fx); Add(idx,fy);
        if(idx == 2*n-1) break;
    }
}
void dfs(int u,int ff)
{
    dep[u] = dep[ff]+1;
    fa[u][0] = ff;
    for(int i = 0; i <= 19; i++) fa[u][i+1] = fa[fa[u][i]][i];
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff) continue;
        dfs(v,u);
    }
}
int lca(int x,int y)
{
    if(dep[x] < dep[y]) swap(x,y);
    for(int i = 20; i >= 0; i--){
        if(dep[fa[x][i]] >= dep[y]) x = fa[x][i];
        if(x == y) return x;
    }
    for(int i = 20; i >= 0; i--){
        if(fa[x][i] != fa[y][i]){
            x = fa[x][i]; y = fa[y][i];
        }
    }
    return fa[x][0];
}
int main()
{
    int x, y;
    scanf("%d%d%d",&n,&m,&q);
    for(int i = 1; i <= m; i++){
        scanf("%d%d%d",&edge[i].u,&edge[i].v,&edge[i].w);
    }
    kruskal();
    dfs(idx,0);
    while(q--){
        scanf("%d%d",&x,&y);
        printf("%d\n",a[lca(x,y)]);
    }
    return 0;
}
```

### splay伸展树

p4146 序列终结者

给定区间l,r实现三种操作

1.区间内所有数加x

2.翻转区间

3.求区间最大值

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e4 + 5;
const int inf = 1e9;
int a[maxn], key[maxn], siz[maxn], fa[maxn], cnt[maxn];
int tag[maxn], add[maxn], mx[maxn], ch[maxn][2];
int root, tot;
inline int read()
{
    int s = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ (s *= 10) += ch-'0'; ch = getchar(); }
    return s*f;
}
void pushup(int x)
{
    siz[x] = siz[ch[x][0]]+siz[ch[x][1]]+cnt[x];
    mx[x] = max(key[x],max(mx[ch[x][0]],mx[ch[x][1]]));
}
void pushdown(int x)
{
    int ls = ch[x][0], rs = ch[x][1];
    if(add[x]){
        if(ls) add[ls] += add[x], key[ls] += add[x], mx[ls] += add[x];
        if(rs) add[rs] += add[x], key[rs] += add[x], mx[rs] += add[x];
    }
    if(tag[x]) tag[ls] ^= 1, tag[rs] ^= 1, swap(ch[x][0],ch[x][1]);
    tag[x] = add[x] = 0;
}
int build(int f,int l,int r)
{
    if(l > r) return 0;
    int now = ++tot, mid = (l+r)>>1;
    key[now] = mx[now] = a[mid]; fa[now] = f;
    cnt[now]++;
    ch[now][0] = build(now,l,mid-1);
    ch[now][1] = build(now,mid+1,r);
    pushup(now);
    return now;
}
int get(int x){ return ch[fa[x]][1] == x; }
void Rotate(int x)
{
    int old = fa[x], oldf = fa[old], k = get(x);
    pushdown(old); pushdown(x);
    ch[old][k] = ch[x][k^1]; fa[ch[old][k]] = old;
    ch[x][k^1] = old; fa[old] = x;
    fa[x] = oldf;
    if(oldf) ch[oldf][ch[oldf][1] == old] = x;
    pushup(old); pushup(x);
}
void splay(int x,int goal)
{
    for(int f; (f = fa[x]) != goal; Rotate(x)){
        if(fa[f] != goal){
            Rotate((get(f) == get(x) ? f : x));
        }
    }
    if(!goal) root = x;
}
int query_Kth(int x)
{
    int now = root;
    while(now){
        pushdown(now);
        if(x <= siz[ch[now][0]]) now = ch[now][0];
        else{
            x -= siz[ch[now][0]]+cnt[now];
            if(x <= 0) return now;
            now = ch[now][1];
        }
    }
    return 0;
}
void change(int l,int r)
{
    l = query_Kth(l); r = query_Kth(r+2); //要操作的区间现在在根节点的右儿子的左儿子
    splay(l,0); splay(r,l);
}
int main()
{
    int n, m, op, l, r, x;
    n = read(); m = read();
    a[1] = -inf; a[n+2] = inf; mx[0] = -inf;
    root = build(0,1,n+2);
    while(m--){
        op = read(); l = read(); r = read();
        change(l,r);
        int k = ch[ch[root][1]][0];
        if(op == 1){
            x = read(); add[k] += x; mx[k] += x; key[k] += x;
        }
        else if(op == 2) tag[k] ^= 1;
        else printf("%d\n",mx[k]);
    }
    return 0;
}
```

牛客 双向链表练习题

初始n个列表，每个列表一个数为i 每次操作将列表a和列表b相加再翻转，给列表赋给列表a，然后列表b清0

splay模拟，建n个树，每次操作就合并，翻转打标记

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int tot;
int T[maxn], fa[maxn], key[maxn], siz[maxn], cnt[maxn];
int ch[maxn][2], tag[maxn];
int Insert(int val)
{
    ++tot;
    fa[tot] = 0; key[tot] = val; siz[tot] = cnt[tot] = 1;
    ch[tot][0] = ch[tot][1] = tag[tot] = 0;
    return tot;
}
void pushup(int x)
{
    if(x){
        siz[x] = cnt[x];
        if(ch[x][0]) siz[x] += siz[ch[x][0]];
        if(ch[x][1]) siz[x] += siz[ch[x][1]];
    }
}
void pushdown(int x)
{
    if(x && tag[x]){
        tag[ch[x][0]] ^= 1; tag[ch[x][1]] ^= 1;
        swap(ch[x][0],ch[x][1]);
        tag[x] = 0;
    }
}
int get(int x){ return ch[fa[x]][1] == x; }
void Rotate(int x)
{
    int old = fa[x], oldf = fa[old], k = get(x);
    pushdown(old); pushdown(x);
    ch[old][k] = ch[x][k^1]; fa[ch[old][k]] = old;
    ch[x][k^1] = old; fa[old] = x;
    fa[x] = oldf;
    if(oldf) ch[oldf][ch[oldf][1] == old] = x;
    pushup(old); pushup(x);
}
void splay(int x,int goal,int rt)
{
    stack<int> st;
    for(int i = x; i; i = fa[i]) st.push(i);
    while(!st.empty()){
        pushdown(st.top()); st.pop();
    }
    for(int f; (f = fa[x]) != goal; Rotate(x)){
        if(fa[f] != goal){
            Rotate((get(x) == get(f) ? f : x));
        }
    }
    if(!goal) T[rt] = x;
}
void Merge(int x,int y)
{
    if(!T[x] && !T[y]) return ;
    else if(!T[x]){
        T[x] = T[y]; T[y] = 0;
        tag[T[x]] ^= 1;
    }
    else if(!T[y]){
        tag[T[x]] ^= 1;
    }
    else{
        int tmp = T[x];
        pushdown(tmp);
        while(ch[tmp][1]) tmp = ch[tmp][1], pushdown(tmp);
        splay(tmp,0,x);
        fa[T[y]] = tmp; ch[tmp][1] = T[y];
        pushup(tmp); pushup(T[y]);
        tag[T[x]] ^= 1;
        T[y] = 0;
    }
}
void dfs(int x)
{
    pushdown(x);
    if(ch[x][0]) dfs(ch[x][0]);
    printf("%d ",key[x]);
    if(ch[x][1]) dfs(ch[x][1]);
}
int main()
{
    int n, m, x, y;
    while(scanf("%d%d",&n,&m) != EOF){
        tot = 0;
        for(int i = 1; i <= n; i++) T[i] = Insert(i);
        for(int i = 1; i <= m; i++){
            scanf("%d%d",&x,&y);
            Merge(x,y);
        }
        printf("%d ",siz[T[1]]);
        if(siz[T[1]]) dfs(T[1]);
        printf("\n");
    }
    return 0;
}
```

### Link_Cut_Tree

维护链信息

洛谷 弹飞绵羊

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int mod = 998244353;
const int maxn = 2e5 + 5;
int a[maxn];
struct Link_Cut_Tree
{
    int top;
    int ch[maxn][2], fa[maxn], sta[maxn], siz[maxn];
    bool tag[maxn];
    bool isRoot(int x){ return !(ch[fa[x]][0] == x || ch[fa[x]][1] == x); }
    bool isRight(int x){ return ch[fa[x]][1] == x; }
    void pushrev(int x){ swap(ch[x][0],ch[x][1]); tag[x] ^= 1; }
    void pushdown(int x){
        if(tag[x]){
            if(ch[x][0]) pushrev(ch[x][0]);
            if(ch[x][1]) pushrev(ch[x][1]);
            tag[x] = false;
        }
    }
    void pushup(int x){
        int ls = ch[x][0], rs = ch[x][1];
        siz[x] = siz[ls]+siz[rs]+1;
    }
    void Rotate(int x){
        int y = fa[x], k = isRight(x);
        int z = fa[y], kk = isRight(y);
        fa[x] = z;
        if(!isRoot(y)) ch[z][kk] = x;
        int tmp = ch[x][k^1];
        fa[tmp] = y; ch[y][k] = tmp; pushup(y);
        fa[y] = x; ch[x][k^1] = y; pushup(x);
    }
    void splay(int x){
        int y = x;
        sta[++top] = y;
        while(!isRoot(y)) sta[++top] = y = fa[y];
        while(top) pushdown(sta[top--]);
        while(!isRoot(x)){
            y = fa[x]; int z = fa[y];
            if(!isRoot(y)) Rotate((ch[y][0] == x)^(ch[z][0] == y) ? x : y);
            Rotate(x);
        }
    }
    void access(int x){
        for(int y = 0; x > 0; y = x, x = fa[x]){
            splay(x);
            ch[x][1] = y;
            pushup(x);
        }
    }
    void setRoot(int x){
        access(x); splay(x); pushrev(x);
    }
    void split(int x,int y){
        setRoot(x); access(y); splay(y);
    }
    int findRoot(int x){
        access(x); splay(x);
        while(ch[x][0]) pushdown(x), x = ch[x][0];
        splay(x);
        return x;
    }
    void link(int x,int y){
        setRoot(x);
        if(findRoot(y) != x) fa[x] = y;
    }
    void cut(int x,int y){
        setRoot(x);
        if(findRoot(y) == x && fa[y] == x && !ch[y][0]){
            fa[y] = ch[x][1] = 0;
            pushup(x);
        }
    }
} lct;
int main()
{
    int n, m;
    scanf("%d",&n);
    for(int i = 1; i <= n+1; i++) lct.siz[i] = 1;
    for(int i = 1; i <= n; i++){
        scanf("%d",&a[i]);
        if(i+a[i] <= n) lct.link(i,i+a[i]);
        else lct.link(i,n+1);
    }
    scanf("%d",&m);
    while(m--){
        int op, x, y;
        scanf("%d%d",&op,&x); x++;
        if(op == 1){
            lct.setRoot(x);
            lct.access(n+1);
            lct.splay(n+1);
            printf("%d\n",lct.siz[n+1]-1);
        }
        else{
            scanf("%d",&y);
            if(x+a[x] <= n) lct.cut(x,x+a[x]);
            else lct.cut(x,n+1);
            a[x] = y;
            if(x+a[x] <= n) lct.link(x,x+a[x]);
            else lct.link(x,n+1);
        }
    }
    return 0;
}
```

维护子树信息

P4219 [BJOI2014]大融合

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int mod = 998244353;
const int maxn = 2e5 + 5;
char s[5];
struct Link_Cut_Tree
{
    int top;
    int ch[maxn][2], fa[maxn], sta[maxn], siz[maxn], sizi[maxn];
    bool tag[maxn];
    bool isRoot(int x){ return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }
    bool isRight(int x){ return ch[fa[x]][1] == x; }
    void pushrev(int x){ swap(ch[x][0],ch[x][1]); tag[x] ^= 1; }
    void pushdown(int x){
        if(tag[x]){
            if(ch[x][0]) pushrev(ch[x][0]);
            if(ch[x][1]) pushrev(ch[x][1]);
            tag[x] = false;
        }
    }
    void pushup(int x){
        int ls = ch[x][0], rs = ch[x][1];
        siz[x] = siz[ls]+siz[rs]+sizi[x]+1;
    }
    void Rotate(int x){
        int y = fa[x], k = isRight(x);
        int z = fa[y], kk = isRight(y);
        fa[x] = z;
        if(!isRoot(y)) ch[z][kk] = x;
        int tmp = ch[x][k^1];
        fa[tmp] = y; ch[y][k] = tmp; pushup(y);
        fa[y] = x; ch[x][k^1] = y; pushup(x);
    }
    void splay(int x){
        int y = x;
        sta[++top] = y;
        while(!isRoot(y)) sta[++top] = y = fa[y];
        while(top) pushdown(sta[top--]);
        for(y = fa[x]; !isRoot(x); Rotate(x), y = fa[x]) {
            if (!isRoot(y)) { Rotate(isRight(x) == isRight(y) ? y : x); }
        }
    }
    void access(int x){
        for(int y = 0; x > 0; y = x, x = fa[x]){
            splay(x);
            sizi[x] += siz[ch[x][1]];
            ch[x][1] = y;
            sizi[x] -= siz[ch[x][1]];
            pushup(x);
        }
    }
    void setRoot(int x){
        access(x); splay(x); pushrev(x);
    }
    void split(int x,int y){
        setRoot(x); access(y); splay(y);
    }
    int findRoot(int x){
        access(x); splay(x); pushdown(x);
        for(; ch[x][0] > 0; x = ch[x][0], pushdown(x));
        return x;
    }
    bool link(int x,int y){
        setRoot(x);
        if(findRoot(y) == x) return 0;
        fa[x] = y;
        sizi[y] += siz[x];
        pushup(y);
        return 1;
    }
    void cut(int x,int y){
        setRoot(x);
        if(findRoot(y) == x && fa[y] == x && !ch[y][0]){
            fa[y] = ch[x][1] = 0;
            pushup(x);
        }
    }
} lct;
int main()
{
    int n, m;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++) lct.siz[i] = 1;
    while(m--){
        int x, y;
        scanf("%s%d%d",s+1,&x,&y);
        if(s[1] == 'A'){
            lct.link(x,y);
        }
        else{
            lct.split(x,y);
            printf("%lld\n",(ll)(lct.sizi[x]+1)*(lct.sizi[y]+1));
        }
    }
    return 0;
}
```



### 动态维护树的直径

计蒜客 2019上海网络赛A题

给定一棵边权树，有两种操作，操作一对第k条边修改权值，操作二询问某点与该点最远的点之间的距离

有一个非常巧妙的做法，考虑树的全DFS序（长度为2n−1的DFS序，允许一个节点在这个DFS序中出现多次）p1,p2,p3,…,p2n−1。

令index(x)表示在全DFS序上节点x第一次出现的下标，即pindex(x)=x。

考虑两个节点x和y，其下标a=index(x),b=index(y)，不妨设a≤b。这两个节点之间的距离

dis(x,y)=dis(r,x)+dis(r,y)−2dis(r,LCA(x,y))=dis(r,x)+dis(r,y)−2mina≤c≤b{dis(r,pc)}.
于是，树的直径则为

maxx,y{dis(x,y)}=max1≤a≤c≤b≤2n−1{dis(r,pa)+dis(r,pb)−2dis(r,pc)}.
我们可以用线段树维护全DFS序在区间上的信息来解决此题，时间复杂度O(n+qlogn)。

对于本题线段树只需维护dis(r,y)-2dis(r,p)的最大值，最后加上该点上的权值即为答案

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
int tot, tim;
char s[5];
int dfn[maxn*2], fa[maxn], in[maxn], out[maxn];
int ver[maxn*2], Next[maxn*2], head[maxn];
ll edge[maxn*2], dis[maxn], w[maxn];
struct Edge{ int u, v; ll w; } E[maxn];
struct node
{
    int l, r;
    ll lazy, val, m, lm, mr;
} tree[maxn*8];
void Add(int x,int y,ll z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
void dfs(int u,int ff)
{
    fa[u] = ff;
    dfn[++tim] = u; in[u] = tim;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff) continue;
        w[v] = edge[i];
        dis[v] = dis[u]+edge[i];
        dfs(v,u);
        dfn[++tim] = u;
    }
    out[u] = tim;
}
void pushup(int k)
{
    int ls = k<<1, rs = k<<1|1;
    tree[k].val = max(tree[ls].val,tree[rs].val);
    tree[k].m = max(tree[ls].m,tree[rs].m);
    tree[k].lm = max(max(tree[ls].lm,tree[rs].lm),tree[ls].val+tree[rs].m);
    tree[k].mr = max(max(tree[ls].mr,tree[rs].mr),tree[ls].m+tree[rs].val);
}
void change(int k,ll d)
{
    tree[k].lazy += d;
    tree[k].val += d;
    tree[k].m -= 2*d;
    tree[k].lm -= d;
    tree[k].mr -= d;
}
void pushdown(int k)
{
    if(!tree[k].lazy) return ;
    change(k<<1,tree[k].lazy);
    change(k<<1|1,tree[k].lazy);
    tree[k].lazy = 0;
}
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r;
    if(l == r){
        tree[k].lazy = 0;
        tree[k].val = dis[dfn[l]];
        tree[k].m = -2*dis[dfn[l]];
        tree[k].lm = tree[k].mr = -dis[dfn[l]];
        return ;
    }
    int mid = (l+r)>>1;
    build(k<<1,l,mid); build(k<<1|1,mid+1,r);
    pushup(k);
}
void update(int k,int l,int r,ll x)
{
    if(tree[k].l == l && tree[k].r == r){
        change(k,x);
        return ;
    }
    pushdown(k);
    int mid = (tree[k].l+tree[k].r)>>1;
    if(mid >= r) update(k<<1,l,r,x);
    else if(mid < l) update(k<<1|1,l,r,x);
    else{
        update(k<<1,l,mid,x); update(k<<1|1,mid+1,r,x);
    }
    pushup(k);
}
node Merge(node x,node y)
{
    node res;
    res.val = max(x.val,y.val);
    res.m = max(x.m,y.m);
    res.lm = max(max(x.lm,y.lm),x.val+y.m);
    res.mr = max(max(x.mr,y.mr),x.m+y.val);
    return res;
}
node query(int k,int l,int r)
{
    if(tree[k].l == l && tree[k].r == r){
        return tree[k];
    }
    pushdown(k);
    int mid = (tree[k].l+tree[k].r)>>1;
    if(mid >= r) return query(k<<1,l,r);
    else if(mid < l) return query(k<<1|1,l,r);
    else{
        return Merge(query(k<<1,l,mid),query(k<<1|1,mid+1,r));
    }
}
int main()
{
    int n, m, x, y;
    ll ans;
    scanf("%d",&n);
    for(int i = 1; i < n; i++){
        scanf("%d%d%lld",&E[i].u,&E[i].v,&E[i].w);
        Add(E[i].u,E[i].v,E[i].w);
        Add(E[i].v,E[i].u,E[i].w);
    }
    dfs(1,0);
    build(1,1,tim);
    scanf("%d",&m);
    while(m--){
        scanf("%s%d",s,&x);
        if(s[0] == 'Q'){
            node ans1 = query(1,1,in[x]);
            node ans2 = query(1,in[x],tim);
            node ans3 = query(1,in[x],in[x]);
            ans = max(ans1.lm,ans2.mr)+ans3.val;
            printf("%lld\n",ans);
        }
        else{
            scanf("%d",&y);
            int tmp = fa[E[x].u] == E[x].v ? E[x].u : E[x].v;
            update(1,in[tmp],out[tmp],(ll)y-w[tmp]);
            w[tmp] = y;
        }
    }
    return 0;
}
```



## 图论

### 最短路径

#### dijkstra

dijkstra+堆优化

洛谷P4779 dijkstra模板题

```c++
void Add(int x,int y,int z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
void dijkstra()
{
    priority_queue<pair<int,int> > q;
    memset(dis,0x3f,sizeof(dis));
    q.push(make_pair(0,s));
    dis[s] = 0;
    while(!q.empty()){
        int x = q.top().second; q.pop();
        if(vis[x]) continue;
        vis[x] = 1;
        for(int i = head[x],y,z; i; i = Next[i]){
            y = ver[i]; z = edge[i];
            if(dis[y] > dis[x]+z){
                dis[y] = dis[x]+z;
                q.push(make_pair(-dis[y],y));
            }
        }
    }
}
```

#### floyd

洛谷 P1119 灾后重建

floyd思想通过其他的点进行中转来求的两点之间的最短路，因此当有一个新点出现时，就用floyd更新一下即可得到此时的最短路

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 205;
int a[maxn], f[maxn][maxn];
int main()
{
    int n, m, x, y, z;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++){
        scanf("%d",&a[i]);
    }
    memset(f,0x3f,sizeof(f));
    for(int i = 1; i <= n; i++) f[i][i] = 0;
    for(int i = 1; i <= m; i++){
        scanf("%d%d%d",&x,&y,&z);
        x++; y++;
        f[x][y] = f[y][x] = z;
    }
    int q, p = 1;
    scanf("%d",&q);
    while(q--){
        scanf("%d%d%d",&x,&y,&z);
        x++; y++;
        while(p <= n && a[p] <= z){
            for(int i = 1; i <= n; i++){
                for(int j = 1; j <= n; j++){
                    f[i][j] = min(f[i][j],f[i][p]+f[p][j]);
                }
            }
            p++;
        }
        if(a[x] > z || a[y] > z || f[x][y] == 0x3f3f3f3f) printf("-1\n");
        else printf("%d\n",f[x][y]);
    }
    return 0;
}
```

### 最小生成树

#### kruskal

P1546 最短网络 Agri-Net

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int cnt, ans;
int prt[maxn];
struct edge{ int x, y, z; } g[maxn];
bool cmp(edge g1,edge g2)
{
    return g1.z < g2.z;
}
int getpa(int x){ return prt[x] == x ? x : prt[x] = getpa(prt[x]); }
int kruskal()
{
    for(int i = 1; i <= cnt; i++){
        int x = getpa(g[i].x);
        int y = getpa(g[i].y);
        if(x == y) continue;
        prt[x] = y;
        ans += g[i].z;
    }
}
int main()
{
    int x, n;
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        prt[i] = i;
        for(int j = 1; j <= n; j++){
            scanf("%d",&x);
            if(x) g[++cnt] = (edge){i,j,x};
        }
    }
    sort(g+1,g+cnt+1,cmp);
    kruskal();
    printf("%d\n",ans);
    return 0;
}
```

#### prim

P1265 公路修建

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 5005;
int n;
ll d[maxn];
bool v[maxn];
struct node{ int x, y; } q[maxn];
ll calc(node q1,node q2)
{
    return (ll)(q1.x-q2.x)*(q1.x-q2.x)+(ll)(q1.y-q2.y)*(q1.y-q2.y);
}
void prim()
{
    memset(d,0x3f,sizeof(d));
    memset(v,0,sizeof(v));
    d[1] = 0;
    for(int i = 1; i < n; i++){
        int x = 0;
        for(int j = 1; j <= n; j++){
            if(!v[j] && (!x || d[j] < d[x])) x = j;
        }
        v[x] = 1;
        for(int y = 1; y <= n; y++){
            if(!v[y]) d[y] = min(d[y],calc(q[x],q[y]));
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%d%d",&q[i].x,&q[i].y);
    }
    prim();
    double ans = 0;
    for(int i = 2; i <= n; i++) ans += sqrt(d[i]*1.0);
    printf("%.2f\n",ans);
    return 0;
}
```

### 虚树

一颗树，每回给k个点，要求使得1号点不能到达这k个点的最小代价

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 3e5 + 5;
const int mod = 1e9 + 7;
int tot, times, top, res;
ll f[maxn];
int sta[maxn], tag[maxn];
int fa[maxn][21], dep[maxn], mn[maxn][21], a[maxn], dfn[maxn];
int ver[maxn*2], edge[maxn*2], Next[maxn*2], head[maxn];
void Add(int x,int y,int z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
void dfs1(int u,int ff)
{
    fa[u][0] = ff; dfn[u] = ++times;
    dep[u] = dep[ff]+1;
    for(int i = 0; i <= 19; i++){
        fa[u][i+1] = fa[fa[u][i]][i];
        mn[u][i+1] = min(mn[u][i],mn[fa[u][i]][i]);
    }
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff) continue;
        mn[v][0] = edge[i];
        dfs1(v,u);
    }
}
bool cmp(int x,int y){ return dfn[x] < dfn[y]; }
int lca(int x,int y)
{
    res = 1e9;
    if(dep[x] < dep[y]) swap(x,y);
    for(int i = 20; i >= 0; i--){
        if(dep[fa[x][i]] >= dep[y]){
            res = min(res,mn[x][i]);
            x = fa[x][i];
        }
        if(x == y) return x;
    }
    for(int i = 20; i >= 0; i--){
        if(fa[x][i] != fa[y][i]){
            res = min(res,min(mn[x][i],mn[y][i]));
            x = fa[x][i]; y = fa[y][i];
        }
    }
    res = min(res,min(mn[x][0],mn[y][0]));
    return fa[x][0];
}
void dfs2(int u,int ff)
{
    f[u] = 0;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff) continue;
        dfs2(v,u);
        if(tag[v]) f[u] += edge[i];
        else f[u] += min(f[v],(ll)edge[i]);
    }
}
int main()
{
    int n, x, y, z;
    scanf("%d",&n);
    for(int i = 1; i < n; i++){
        scanf("%d%d%d",&x,&y,&z);
        Add(x,y,z); Add(y,x,z);
    }
    dfs1(1,0);
    int m;
    scanf("%d",&m);
    while(m--){
        int k;
        scanf("%d",&k);
        for(int i = 1; i <= k; i++) scanf("%d",&a[i]), tag[a[i]] = 1;
        sort(a+1,a+k+1,cmp);
        top = tot = 0;
        sta[++top] = 1; head[1] = 0;
        for(int i = 1; i <= k; i++){ //建虚树
            if(a[i] != 1){
                int tmp = lca(a[i],sta[top]);
                if(tmp != sta[top]){
                    while(dfn[tmp] < dfn[sta[top-1]]){
                        lca(sta[top-1],sta[top]);
                        Add(sta[top-1],sta[top],res);
                        top--;
                    }
                    if(dfn[tmp] > dfn[sta[top-1]]){ //大于和不等于一样
                        head[tmp] = 0; lca(tmp,sta[top]);
                        Add(tmp,sta[top],res); sta[top] = tmp;
                    }
                    else{ //说明lca就是次大节点
                        lca(tmp,sta[top]); Add(tmp,sta[top--],res);
                    }
                }
                head[a[i]] = 0; sta[++top] = a[i];
            }
        }
        for(int i = 1; i < top; i++){ //处理最后一条链
            lca(sta[i],sta[i+1]); Add(sta[i],sta[i+1],res);
        }
        dfs2(1,0);
        printf("%lld\n",f[1]);
        for(int i = 1; i <= k; i++) tag[a[i]] = 0;
    }
    return 0;
}
```



### 负环和差分约束

对于xi - xj <= c 变形为 xi <= xj+c 就是由xj 向 xi 连一条长度为c 的边 相等的情况 连两条

bfs

洛谷 P5960 【模板】差分约束算法

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 5e3 + 5;
int tot, n;
int d[maxn], v[maxn], cnt[maxn];
int ver[maxn*2], edge[maxn*2], Next[maxn*2], head[maxn];
void Add(int x,int y,int z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
bool spfa()
{
    memset(d,0x3f,sizeof(d));
    d[0] = 0; v[0] = 1;
    queue<int> q;
    q.push(0);
    while(!q.empty()){
        int x = q.front(); q.pop();
        v[x] = 0;
        for(int i = head[x]; i; i = Next[i]){
            int y = ver[i], z = edge[i];
            if(d[y] > d[x]+z){
                d[y] = d[x]+z; cnt[y] = cnt[x]+1;
                if(cnt[y] >= n+1 && z < 0) return false;
                if(!v[y]) q.push(y), v[y] = 1;
            }
        }
    }
    return true;
}
int main()
{
    int m, x, y, z;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++) Add(0,i,0); //设立源点
    for(int i = 1; i <= m; i++){
        scanf("%d%d%d",&x,&y,&z);
        Add(y,x,z);
    }
    if(spfa()){
        for(int i = 1; i <= n; i++) printf("%d ",d[i]);
        printf("\n");
    }
    else printf("NO\n");
    return 0;
}
```

dfs

洛谷 P1993 小K的农场

本题使用bfs版spfa无法通过会超时，需要用dfs版spfa

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 4e4 + 5;
int tot, n;
int d[maxn], v[maxn], cnt[maxn];
int ver[maxn], edge[maxn], Next[maxn], head[maxn];
void Add(int x,int y,int z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
bool spfa(int x)
{
    v[x] = 1;
    for(int i = head[x]; i; i = Next[i]){
        int y = ver[i], z = edge[i];
        if(d[y] > d[x]+z){
            d[y] = d[x]+z;
            if(v[y]) return false;
            if(!spfa(y)) return false;
        }
    }
    v[x] = 0;
    return true;
}
int main()
{
    int m, op, x, y, z;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++) Add(0,i,0);
    for(int i = 1; i <= m; i++){
        scanf("%d%d%d",&op,&x,&y);
        if(op == 1){
            scanf("%d",&z);
            Add(x,y,-z);
        }
        else if(op == 2){
            scanf("%d",&z);
            Add(y,x,z);
        }
        else{
            Add(x,y,0); Add(y,x,0);
        }
    }
    memset(d,0x3f,sizeof(d));
    d[0] = 0;
    if(spfa(0)) printf("Yes\n");
    else printf("No\n");
    return 0;
}
```



### 分层图最短路

洛谷 P4568 [JLOI2011]飞行路线

只需要在dij中稍作修改，考虑免费走与不免费走两种情况

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4 + 5;
const int M = 1e5 + 5;
int tot, n, k;
int dis[N][15], vis[N][15];
int ver[M], edge[M], Next[M], head[N];
priority_queue<pair<int,int> > q;
void Add(int x,int y,int z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
void dijkstra(int s)
{
    memset(dis,0x3f,sizeof(dis));
    q.push(make_pair(0,s));
    dis[s][0] = 0;
    while(!q.empty()){
        int x = q.top().second; q.pop();
        int tmp = x%n;
        if(!tmp) tmp = n;
        int c = (x-tmp)/n; x = tmp;
        if(vis[x][c]) continue;
        vis[x][c] = 1;
        for(int i = head[x]; i; i = Next[i]){
            int y = ver[i], z = edge[i];
            if(k > c && dis[y][c+1] > dis[x][c]){ //免费
                dis[y][c+1] = dis[x][c];
                q.push(make_pair(-dis[y][c+1],y+(c+1)*n));
            }
            if(dis[y][c] > dis[x][c]+z){ //不免费
                dis[y][c] = dis[x][c]+z;
                q.push(make_pair(-dis[y][c],y+c*n));
            }
        }
    }
}
int main()
{
    int m, s, t;
    scanf("%d%d%d%d%d",&n,&m,&k,&s,&t);
    s++; t++;
    int x, y, z;
    for(int i = 1; i <= m; i++){
        scanf("%d%d%d",&x,&y,&z);
        x++; y++;
        Add(x,y,z); Add(y,x,z);
    }
    dijkstra(s);
    int ans = 1e9;
    for(int i = 0; i <= k; i++){
        ans = min(ans,dis[t][i]);
    }
    printf("%d\n",ans);
    return 0;
}
```



### 拓扑排序

拓扑排序可用来判断图是否有环，拓扑序列个数小于点数，即有环。

牛客  Applese 的QQ群   https://ac.nowcoder.com/acm/contest/330/F 

本题必然是在某一个位置no后，以后全是no，所以可以二分这个位置在哪，每次利用拓扑排序检查前面的边是否构成环。

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 5;
int tot, n;
int in[maxn];
int ver[maxn], Next[maxn], head[maxn];
struct node{ int x, y; } q[maxn];
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
bool topsort()
{
    queue<int> qq;
    vector<int> a;
    a.clear();
    for(int i = 1; i <= n; i++){
        if(!in[i]) qq.push(i);
    }
    while(!qq.empty()){
        int u = qq.front(); qq.pop();
        a.push_back(u);
        for(int i = head[u]; i; i = Next[i]){
            int v = ver[i];
            if(--in[v] == 0) qq.push(v);
        }
    }
    if(a.size() == n) return true;
    return false;
}
bool check(int x)
{
    tot = 0;
    for(int i = 1; i <= n; i++){
        head[i] = in[i] = 0;
    }
    for(int i = 1; i <= x; i++){
        Add(q[i].x,q[i].y);
        in[q[i].y]++;
    }
    if(topsort()) return true;
    return false;
}
int main()
{
    int m;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= m; i++){
        scanf("%d%d",&q[i].x,&q[i].y);
    }
    int l = 1, r = m, mid, ans = 0;
    while(l <= r){
        mid = (l+r)>>1;
        if(check(mid)) ans = mid, l = mid+1;
        else r = mid-1;c++
    }
    for(int i = 1; i <= m; i++){
        if(i <= ans) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```

### tarjan

#### 无向图

##### 割点

若x不是搜索树的根节点(深度优先遍历的起点)，则 x 是割点当且仅当搜索树上存在 x 的一个子节点 y ，满足：dfn[x] <= low[y]

若x是搜索树的根节点，则x是割点当且仅当搜索树上存在至少两个子节点y1，y2满足以上条件

代码为求无向图上割点个数并输出

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 2e4 + 5;
const int M = 1e5 + 5;
int tot, num, cnt, root;
int ver[M*2], Next[M*2], head[N];
int dfn[N], low[N], cut[N];
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
void tarjan(int x)
{
    dfn[x] = low[x] = ++num;
    int flag = 0;
    for(int i = head[x]; i; i = Next[i]){
        int y = ver[i];
        if(!dfn[y]){
            tarjan(y);
            low[x] = min(low[x],low[y]);
            if(dfn[x] <= low[y]){
                flag++;
                if(x != root || flag >= 2){
                    if(!cut[x]) cnt++;
                    cut[x] = 1;
                } 
            }
        }
        else low[x] = min(low[x],dfn[y]);
    }
}
int main()
{
    int n, m, x, y;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= m; i++){
        scanf("%d%d",&x,&y);
        Add(x,y); Add(y,x);
    }
    for(int i = 1; i <= n; i++){
        if(!dfn[i]) root = i, tarjan(i);
    }
    printf("%d\n",cnt);
    for(int i = 1; i <= n; i++){
        if(cut[i]) printf("%d ",i);
    }
    printf("\n");
    return 0;
}
```

##### 边双连通分量

若一张无向连通图不存在割边，则称它为 边双连通图 无向图的极大边双连通子图称为 边双连通分量

牛客 https://ac.nowcoder.com/acm/contest/3566/E

在一个连通图上加一条边使得随机选一条边，该边为桥的概率最小，求概率

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 5;
const int mod = 1e9 + 7;
int tot, num, dcc, tc, total, ans;
bool bridge[maxn*2];
int f[maxn][2];
int ver[maxn*2], Next[maxn*2], head[maxn];
int vc[maxn*2], nc[maxn*2], hc[maxn];
int dfn[maxn], low[maxn], col[maxn];
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
void Add_c(int x,int y)
{
    vc[++tc] = y; nc[tc] = hc[x]; hc[x] = tc;
}
void tarjan(int u,int in_edge) //求割边
{
    dfn[u] = low[u] = ++num;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(!dfn[v]){
            tarjan(v,i);
            low[u] = min(low[u],low[v]);
            if(low[v] > dfn[u]){
                bridge[i] = bridge[i^1] = true;
            }
        }
        else if(i != (in_edge^1)){
            low[u] = min(low[u],dfn[v]);
        }
    }
}
void dfs1(int u) //联通块染色
{
    col[u] = dcc;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(col[v] || bridge[i]) continue;
        dfs1(v);
    }
}
void dfs2(int u,int ff) //求缩点后的树的直径
{
    for(int i = hc[u]; i; i = nc[i]){
        int v = vc[i];
        if(v == ff) continue;
        dfs2(v,u);
        if(f[v][0]+1 > f[u][0]){
            f[u][1] = f[u][0];
            f[u][0] = f[v][0]+1;
        }
        else f[u][1] = max(f[u][1],f[v][0]+1);
    }
    ans = max(ans,f[u][0]+f[u][1]);
}
int qp(int x,int y)
{
    int res = 1;
    while(y){
        if(y&1) res = (ll)res*x%mod;
        y >>= 1;
        x = (ll)x*x%mod;
    }
    return res;
}
int main()
{
    int n, m, x, y;
    scanf("%d%d",&n,&m);
    tot = 1;
    for(int i = 1; i <= m; i++){
        scanf("%d%d",&x,&y);
        Add(x,y); Add(y,x);
    }
    tarjan(1,0);
    for(int i = 1; i <= n; i++){
        if(!col[i]){
            ++dcc;
            dfs1(i);
        }
    }
    //边双连通分量 缩点
    tc = 1;
    for(int i = 2; i <= tot; i++){
        x = ver[i^1], y = ver[i];
        if(col[x] == col[y]) continue;
        Add_c(col[x],col[y]);
        total++;
    }
    total /= 2;
    dfs2(1,0);
    printf("%lld\n",(ll)(total-ans)*qp(m+1,mod-2)%mod);
    return 0;
}

```

##### 点双连通分量

若一张无向图不存在割点，则称它为点双连通图，无向图的极大点双连通子图为点双连通分量

```c++
void tarjan(int x)
{
    dfn[x] = low[x] = ++num;
    sta[++top] = x;
    if(x == root && !head[x]){
        dcc[++cnt].push_back(x);
        c[x] = cnt;
        return ;
    }
    int flag = 0;
    for(int i = head[x]; i; i = Next[i]){
        int y = ver[i];
        if(!dfn[y]){
            tarjan(y);
            low[x] = min(low[x],low[y]);
            if(low[y] >= dfn[x]){
                flag++;
                if(x != root || flag > 1) cut[x] = 1;
                cnt++;
                int z;
                do{
                    z = sta[top--];
                    dcc[cnt].push_back(z);
                    c[z] = cnt;
                } while(z != y);
                dcc[cnt].push_back(x);
            }
        }
        else low[x] = min(low[x],dfn[y]);
    }
}
int main()
{
    for(int i = 1; i <= mx; i++){
        if(!dfn[i]) root = i, tarjan(i);
    }
    //缩点
    num = cnt;
    for(int i = 1; i <= n; i++){
        if(cut[i]) new_id[i] = ++num;
    }
    tc = 1;
    for(int i = 1; i <= cnt; i++){
        for(int j = 0; j < dcc[i].size(); j++){
            int x = dcc[i][j];
            if(cut[x]){
                Add_c(i,new_id[x]);
                Add_c(new_id[x],i);
            }
            else c[x] = i;
        }
    }
}
```

#### 有向图

##### 强连通分量

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int tot, num, top, cnt;
int c[maxn];
int ver[maxn], Next[maxn], head[maxn];
int dfn[maxn], low[maxn], sta[maxn], ins[maxn];
vector<int> scc[maxn];
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
void tarjan(int x)
{
    dfn[x] = low[x] = ++num;
    sta[++top] = x; ins[x] = 1;
    for(int i = head[x]; i; i = Next[i]){
        int y = ver[i];
        if(!dfn[y]){
            tarjan(y);
            low[x] = min(low[x],low[y]);
        }
        else if(ins[y]){
            low[x] = min(low[x],dfn[y]);
        }
    }
    if(dfn[x] == low[x]){
        cnt++; int y;
        do{
            y = sta[top--]; ins[y] = 0;
            c[y] = cnt; scc[cnt].push_back(y);
        } while(x != y);
    }
}
int main()
{
    int n, m, x, y;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= m; i++){
        scanf("%d%d",&x,&y);
        Add(x,y);
    }
    for(int i = 1; i <= n; i++){
        if(!dfn[i]) tarjan(i);
    }
    return 0;
}
```

##### 缩点

```c++
void Add_c(int x,int y)
{
    vc[++tc] = y; nc[tc] = hc[x]; hc[x] = tc;
}
int main()
{
    for(int x = 1; x <= n; x++){
        for(int i = head[x]; i; i = Next[i]){
            int y = ver[i];
            if(c[x] != c[y]) Add_c(c[x],c[y]);
        }
    }
}
```

### 2-SAT

洛谷 P4782 【模板】2-SAT 问题

有n个变量和m个条件，每个条件为 x为a或y为b a，b为{0，1} 

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e6 + 5;
int tot, num, top, cnt;
int c[maxn], opp[maxn];
int ver[maxn], Next[maxn], head[maxn];
int dfn[maxn], low[maxn], sta[maxn], ins[maxn];
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
void tarjan(int x)
{
    dfn[x] = low[x] = ++num;
    sta[++top] = x; ins[x] = 1;
    for(int i = head[x]; i; i = Next[i]){
        int y = ver[i];
        if(!dfn[y]){
            tarjan(y);
            low[x] = min(low[x],low[y]);
        }
        else if(ins[y]){
            low[x] = min(low[x],dfn[y]);
        }
    }
    if(dfn[x] == low[x]){
        cnt++; int y;
        do{
            y = sta[top--]; ins[y] = 0;
            c[y] = cnt;
        } while(x != y);
    }
}
int main()
{
    int n, m, x, y, a, b;
    scanf("%d%d",&n,&m);
    tot = 1;
    for(int i = 1; i <= m; i++){
        scanf("%d%d%d%d",&x,&a,&y,&b);
        Add(x+(1-a)*n,y+b*n);
        Add(y+(1-b)*n,x+a*n);
    }
    for(int i = 1; i <= 2*n; i++){
        if(!dfn[i]) tarjan(i);
    }
    for(int i = 1; i <= n; i++){
        if(c[i] == c[i+n]){
            printf("IMPOSSIBLE\n"); return 0;
        }
        opp[i] = n+i; opp[n+i] = i;
    }
    printf("POSSIBLE\n");
    for(int i = 1; i <= n; i++){
        printf("%d ",c[i] > c[opp[i]]);
    }
    printf("\n");
    return 0;
}
```



### 二分图

#### 二分图判定

牛客 关押罪犯

二分答案+二分图判定

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5 + 5;
int m, tot, n, mid;
bool flag;
int vis[maxn];
int ver[maxn*2], Next[maxn*2], edge[maxn*2],head[maxn];
void Add(int x,int y,int z)
{
    ver[++tot] = y; Next[tot] = head[x]; edge[tot] = z; head[x] = tot;
}
void dfs(int u,int color)
{
    vis[u] = color;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(edge[i] > mid){
            if(!vis[v]) dfs(v,3-color);
            else if(vis[v] == color){
                flag = false; return ;
            }
        }
    }
}
bool check()
{
    flag = true;
    for(int i = 1; i <= n; i++) vis[i] = 0;
    for(int i = 1; i <= n; i++){
        if(!vis[i]) dfs(i,1);
    }
    return flag;
}
int main()
{
    int mx = 0;
    scanf("%d%d",&n,&m);
    int x, y, z;
    for(int i = 1; i <= m; i++){
        scanf("%d%d%d",&x,&y,&z);
        Add(x,y,z); Add(y,x,z);
        mx = max(mx,z);
    }
    int l = 0, r = mx, ans;
    while(l <= r){
        mid = (l+r)>>1;
        if(check()) ans = mid, r = mid-1;
        else l = mid+1;
    }
    printf("%d\n",ans);
    return 0;
}

```

#### 最大匹配

洛谷 p3386

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1005;
int tot;
int vis[maxn], match[maxn];
int ver[maxn*maxn], Next[maxn*maxn], head[maxn];
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
bool dfs(int u)
{
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(vis[v]) continue;
        vis[v] = 1;
        if(!match[v] || dfs(match[v])){
            match[v] = u; return true;
        }
    }
    return false;
}
int main()
{
    int n, m, e, x, y;
    scanf("%d%d%d",&n,&m,&e);
    for(int i = 1; i <= e; i++){
        scanf("%d%d",&x,&y);
        if(x > n || y > m) continue;
        Add(x,y);
    }
    int ans = 0;
    for(int i = 1; i <= n; i++){
        memset(vis,0,sizeof(vis));
        if(dfs(i)) ans++;
    }
    printf("%d\n",ans);
    return 0;
}

```

#### 完美匹配

cf1107 f

题意：有n种贷款，每一个月你最多可以选择一个贷款并得到a元的收益，但在月底的时候你需要支付b元并连续支付k个月，你可以在月中的时候买一辆车，问这辆车最大的价值可以是多少。

思路：我们定义f(i,j)=max(0,ai-bi*min(ki,j-1))表示第i个贷款在买车的倒数第j个月买入对答案贡献的价值，我们可以注意到每个月只会有一个贷款买入而且到我们要买车的那个月的时候每个贷款经历的月份是不一样的，所以我们可以建立一个二分图，左边代表基金，右边代表月份，连边的代价就是f(i,j)然后去跑二分图带权最大匹配即可，时间复杂度O(n^3)

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 500 + 5;
const int inf = 0x3f3f3f3f;
int n;
ll delta;
ll w[maxn][maxn];
ll la[maxn], lb[maxn], slack[maxn];
bool vb[maxn];
int match[maxn], pre[maxn];
ll a[maxn], b[maxn], t[maxn];
void bfs(int k)
{
    ll delta;
    int x, y = 0, p = 0;
    memset(pre,0,sizeof(pre));
    for(int i = 1; i <= n; i++) slack[i] = inf;
    match[y] = k;
    while(1){
        x = match[y]; delta = inf; vb[y] = 1;
        for(int i = 1; i <= n; i++){
            if(!vb[i]){
                if(slack[i] > la[x]+lb[i]-w[x][i]){
                    slack[i] = la[x]+lb[i]-w[x][i];
                    pre[i] = y;
                }
                if(slack[i] < delta) delta = slack[i], p = i;
            }
        }
        for(int i = 0; i <= n; i++){
            if(vb[i]) la[match[i]] -= delta, lb[i] += delta;
            else slack[i] -= delta;
        }
        y = p;
        if(match[y] == -1) break;
    }
    while(y) match[y] = match[pre[y]], y = pre[y];
}
ll KM()
{
    memset(la,0,sizeof(la));
    memset(lb,0,sizeof(lb));
    memset(match,-1,sizeof(match));
    for(int i = 1; i <= n; i++){
        memset(vb,0,sizeof(vb));
        bfs(i);
    }
    ll ans = 0;
    for(int i = 1; i <= n; i++){
        if(match[i] != -1) ans += w[match[i]][i];
    }
    return ans;
}
int main()
{
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%lld%lld%lld",&a[i],&b[i],&t[i]);
        for(int j = 1; j <= n; j++){
            w[i][j] = max(0ll,a[i]-b[i]*min(t[i],(ll)j-1));
        }
    }
    printf("%lld\n",KM());
    return 0;
}
```



### 网络流

#### 最大流

模板

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e4 + 5;
const int M = 2e5 + 5;
const int inf = 1e9;
int tot, S, T, n;
int d[N];
int ver[M], edge[M], Next[M], head[N];
queue<int> q;
void Add(int x,int y,int z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
    ver[++tot] = x; edge[tot] = 0; Next[tot] = head[y]; head[y] = tot;
}
bool bfs() //在残量网络上构造分层图
{
    for(int i = 1; i <= n; i++) d[i] = 0;
    while(!q.empty()) q.pop();
    q.push(S); d[S] = 1;
    while(!q.empty()){
        int x = q.front(); q.pop();
        for(int i = head[x]; i; i = Next[i]){
            if(edge[i] && !d[ver[i]]){
                q.push(ver[i]);
                d[ver[i]] = d[x]+1;
                if(ver[i] == T) return 1;
            }
        }
    }
    return 0;
}
int dinic(int x,int flow) //在当前分层图上增广
{
    if(x == T) return flow;
    int rest = flow, k;
    for(int i = head[x]; i && rest; i = Next[i]){
        if(edge[i] && d[ver[i]] == d[x]+1){
            k = dinic(ver[i],min(rest,edge[i]));
            if(!k) d[ver[i]] = 0; //剪枝，去掉增广完毕的点
            edge[i] -= k;
            edge[i^1] += k;
            rest -= k;
        }
    }
    return flow-rest;
}
int main()
{
    int m;
    scanf("%d%d%d%d",&n,&m,&S,&T);
    int x, y, z;
    tot = 1;                  //要修改为1
    for(int i = 1; i <= m; i++){
        scanf("%d%d%d",&x,&y,&z);
        Add(x,y,z);
    }
    int flow = 0, maxflow = 0;
    while(bfs()){ //修改tot
        while((flow = dinic(S,inf))) maxflow += flow;
    }
    printf("%d\n",maxflow);
    return 0;
}
```

#### 最小割

任何一个网络的最大流量等于最小割中边的容量之和，简记为“最大流 = 最小割”

#### 费用流

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 100 + 5;
const int maxm = 1e5 + 5;
const int inf = 1e9;
int tot, S, T, maxflow, ans;
int a[maxn], d[maxn], v[maxn], incf[maxn], pre[maxn];
int ver[maxm], edge[maxm], Next[maxm], cost[maxm], head[maxn];
void Add(int x,int y,int z,int c)
{
    ver[++tot] = y; edge[tot] = z; cost[tot] = c;
    Next[tot] = head[x]; head[x] = tot;
    ver[++tot] = x; edge[tot] = 0; cost[tot] = -c;
    Next[tot] = head[y]; head[y] = tot;
}
bool spfa()
{
    queue<int> q;
    memset(d,0x3f,sizeof(d));
    memset(v,0,sizeof(v));
    q.push(S); d[S] = 0; v[S] = 1;
    incf[S] = 1<<30; //增广路上各边的最小剩余容量
    while(q.size()){
        int x = q.front(); q.pop();
        v[x] = 0;
        for(int i = head[x]; i; i = Next[i]){
            if(!edge[i]) continue;
            int y = ver[i];
            if(d[y] > d[x]+cost[i]){ //最小费用最大流
                d[y] = d[x]+cost[i];
                incf[y] = min(incf[x],edge[i]);
                pre[y] = i;
                if(!v[y]) v[y] = 1, q.push(y);
            }
        }
    }
    if(d[T] == 0x3f3f3f3f) return false;
    return true;
}
void update()
{
    int x = T;
    while(x != S){
        int i = pre[x];
        edge[i] -= incf[T];
        edge[i^1] += incf[T];
        x = ver[i^1];
    }
    maxflow += incf[T];
    ans += d[T]*incf[T];
}
int main()
{
    int n, sum = 0;
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%d",&a[i]);
        sum += a[i];
    }
    sum /= n;
    S = n+1; T = n+2; tot = 1;
    for(int i = 1; i <= n; i++){
        a[i] -= sum;
        if(a[i] > 0) Add(S,i,a[i],0);
        if(a[i] < 0) Add(i,T,-a[i],0);
    }
    for(int i = 2; i < n; i++){
        Add(i,i-1,inf,1);
        Add(i,i+1,inf,1);
    }
    Add(1,2,inf,1);
    Add(1,n,inf,1);
    Add(n,1,inf,1);
    Add(n,n-1,inf,1);
    while(spfa()) update();
    printf("%d\n",ans);
    return 0;
}
```



## 动态规划

### 区间dp

洛谷P1880 石子合并

每次只能选相邻的2堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

```c++
#include<bits/stdc++.h>
using namespace std;
int a[205], f1[205][205], f2[205][205], sum[205];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%d",&a[i]);
        a[i+n] = a[i];
    }
    for(int i = 1; i <= n*2; i++) sum[i] = sum[i-1]+a[i];
    memset(f1,0x3f,sizeof(f1));
    for(int len = 2; len <= n; len++){
        for(int i = 1; i+len-1 < n*2; i++){
            int j = i+len-1;
            f1[i][i] = 0; f1[j][j] = 0;
            for(int k = i; k < j; k++){
                f1[i][j] = min(f1[i][j],f1[i][k]+f1[k+1][j]);
                f2[i][j] = max(f2[i][j],f2[i][k]+f2[k+1][j]);
            }
            f1[i][j] += sum[j]-sum[i-1];
            f2[i][j] += sum[j]-sum[i-1];
        }
    }
    int ans1 = 0x3f3f3f3f, ans2 = 0;
    for(int i = 1; i <= n; i++){
        ans1 = min(ans1,f1[i][i+n-1]);
        ans2 = max(ans2,f2[i][i+n-1]);
    }
    printf("%d\n%d\n",ans1,ans2);
    return 0;
}
```

### 树形dp

洛谷P2015 二叉苹果树

```c++
#include<bits/stdc++.h>
using namespace std;
int mp[105][105], l[105], r[105], f[105][105], a[105];
int n;
void build(int u)
{
    for(int i = 1; i <= n; i++){    //建左子树
        if(mp[u][i] >= 0){
            l[u] = i; a[i] = mp[u][i];
            mp[u][i] = -1; mp[i][u] = -1;
            build(i);
            break;
        }
    }
    for(int i = 1; i <= n; i++){   //建右子树
        if(mp[u][i] >= 0){
            r[u] = i; a[i] = mp[u][i];
            mp[u][i] = -1; mp[i][u] = -1;
            build(i);
            break;
        }
    }
}
int solve(int i,int j)     //树形dp+记忆化搜索
{
    if(!j) return 0;
    if(!l[i] && !r[i]) return a[i];
    if(f[i][j]) return f[i][j];
    for(int k = 0; k < j; k++){
        f[i][j] = max(f[i][j],solve(l[i],k)+solve(r[i],j-k-1)+a[i]);
    }
    return f[i][j];
}
int main()
{
    int q, x, y, z;
    scanf("%d%d",&n,&q); q++;
    memset(mp,-1,sizeof(mp));
    for(int i = 1; i < n; i++){
        scanf("%d%d%d",&x,&y,&z);
        mp[x][y] = z; mp[y][x] = z;
    }
    build(1);
    printf("%d\n",solve(1,q));
    return 0;
}
```

二次扫描与换根法

poj3585 

找一个点使得，使得从这个点出发作为源点，发出的流量最大，输出这个最大的流量。

```c++
#include<cstdio>
#include<algorithm>
using namespace std;
const int maxn = 2e5 + 5;
int ver[maxn*2], edge[maxn*2], head[maxn], Next[maxn*2];
int d[maxn], f[maxn], in[maxn];
int tot;
void Add(int x,int y,int z)
{
    ver[++tot] = y; edge[tot] = z; Next[tot] = head[x]; head[x] = tot;
}
void dp(int u,int fa)
{
    d[u] = 0;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == fa) continue;
        dp(v,u);
        if(in[v] == 1) d[u] += edge[i];
        else d[u] += min(d[v],edge[i]);
    }
}
void dfs(int u,int fa)
{
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == fa) continue;
        if(in[u] == 1) f[v] = d[v]+edge[i];
        else f[v] = d[v]+min(f[u]-min(edge[i],d[v]),edge[i]);
        dfs(v,u);
    }
}
int main()
{
    int t, n, x, y, z, root;
    scanf("%d",&t);
    while(t--){
        tot = 0;
        scanf("%d",&n);
        for(int i = 1; i <= n; i++){
            head[i] = in[i] = 0;
        }
        for(int i = 1; i < n; i++){
            scanf("%d%d%d",&x,&y,&z);
            in[x]++; in[y]++;
            Add(x,y,z); Add(y,x,z);
        }
        root = 1;
        dp(root,0);
        f[root] = d[root];
        dfs(root,0);
        int ans = 0;
        for(int i = 1; i <= n; i++){
            ans = max(ans,f[i]);
        }
        printf("%d\n",ans);
    }
    return 0;
}
```



### 数位dp

hdu4507

不符合的数满足以下条件

1.整数中某一位是7；

2.整数的每一位加起来的和是7的整数倍；

3.这个整数是7的整数倍。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;
int cnt;
int p[25], a[25];
struct node{ ll cnt, sum1, sum2; } f[25][10][10];
void pre()
{
    p[1] = 1;
    for(int i = 2; i <= 20; i++){
        p[i] = (ll)p[i-1]*10%mod;
    }
}
node dfs(int pos,ll sum,ll sum1,int flag)
{
    node tmp, ans;
    ans.cnt = ans.sum1 = ans.sum2 = 0;
    if(!pos){
        if(sum && sum1) ans.cnt = 1;
        return ans;
    }
    if(!flag && f[pos][sum][sum1].cnt != -1) return f[pos][sum][sum1];
    int ed = flag ? a[pos] : 9;
    for(int i = 0; i <= ed; i++){
        if(i == 7) continue;
        tmp = dfs(pos-1,(i+sum)%7,(i+sum1*10)%7,flag && i == ed);
        (ans.cnt += tmp.cnt) %= mod;
        (ans.sum1 += tmp.cnt*i%mod*p[pos]%mod+tmp.sum1) %= mod;
        (ans.sum2 += (tmp.sum2+2*tmp.sum1%mod*p[pos]%mod*i%mod)%mod) %= mod;
        (ans.sum2 += tmp.cnt*i*i%mod*p[pos]%mod*p[pos]%mod )%= mod;
    }
    if(!flag) f[pos][sum][sum1] = ans;
    return ans;
}
node solve(ll x)
{
    cnt = 0;
    ll tmp = x;
    while(tmp){
        a[++cnt] = tmp%10;
        tmp /= 10;
    }
    return dfs(cnt,0,0,1);
}
int main()
{
    int t;
    ll a, b;
    pre();
    scanf("%d",&t);
    while(t--){
        scanf("%lld%lld",&a,&b);
        for(int i = 0; i <= 20; i++){
            for(int j = 0; j < 7; j++){
                for(int k = 0; k < 7; k++){
                    f[i][j][k].cnt = -1;
                    f[i][j][k].sum1 = 0;
                    f[i][j][k].sum2 = 0;
                }
            }
        }
        printf("%lld\n",(solve(b).sum2-solve(a-1).sum2+mod)%mod);
    }
    return 0;
}
```

洛谷2602

统计a到b的区间中0-9每个数字的出现次数

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int cnt;
int a[25];
ll f[25][25];
ll dfs(int pos,int x,int lead,int flag,int sum)
{
    if(!pos) return sum;
    if(!flag && lead && f[pos][sum] != -1) return f[pos][sum];
    int ed = flag ? a[pos] : 9;
    ll res = 0;
    for(int i = 0; i <= ed; i++){
        if(!lead && !i) res += dfs(pos-1,x,0,flag && i == ed,sum);
        else res += dfs(pos-1,x,1,flag && i == ed,sum+(i == x));
    }
    if(!flag && lead) f[pos][sum] = res;
    return res;
}
ll solve(ll x,int d)
{
    cnt = 0;
    while(x){
        a[++cnt] = x%10;
        x /= 10;
    }
    return dfs(cnt,d,0,1,0);
}
int main()
{
    ll a, b;
    scanf("%lld%lld",&a,&b);
    for(int i = 0; i <= 9; i++){
        memset(f,-1,sizeof(f));
        printf("%lld ",solve(b,i)-solve(a-1,i));
    }
    return 0;
}
```

### 填坑dp

2020wannafly camp day6 D

给定 l 数组和 r 数组 ，构造 a 数组满足 a[i] 在 l[i] 和 r[i] 之间且a数组非严格单调递增，将符合条件的a数组所有元素之和输出

f(i,j) 表示当前选了i个数，都是小于等于第j个区间的方案数

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 100 + 5;
const int mod = 998244353;
ll l[maxn], r[maxn], f[maxn][maxn], a[maxn], sum[maxn][maxn];
ll qp(ll x,ll y)
{
    ll res = 1;
    while(y){
        if(y&1) res = (ll)res*x%mod;
        y >>= 1;
        x = (ll)x*x%mod;
    }
    return res;
}
int main()
{
    int n, cnt = 0;
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%lld",&l[i]);
        a[++cnt] = l[i];
    }
    for(int i = 1; i <= n; i++){
        scanf("%lld",&r[i]);
        a[++cnt] = ++r[i];
    }
    sort(a+1,a+cnt+1);
    cnt = unique(a+1,a+cnt+1)-a-1;
    for(int i = 1; i <= n; i++){
        l[i] = lower_bound(a+1,a+cnt+1,l[i])-a;
        r[i] = lower_bound(a+1,a+cnt+1,r[i])-a;
    }
    for(int i = 0; i <= cnt; i++) f[0][i] = 1, sum[0][i] = 0;
    int inv2 = qp(2,mod-2);
    for(int i = 1; i <= n; i++){
        for(int j = l[i]; j < r[i]; j++){
            ll all = 1;
            for(int k = i; k > 0; k--){
                if(!(l[k] <= j && j < r[k])) break;
                ll num = i-k+1;
                ll len = (a[j+1]-a[j])%mod;
                ll avg = (a[j+1]-1+a[j])%mod*inv2%mod;
                all = all*(len+num-1)%mod*qp(num,mod-2)%mod;
                f[i][j] = (f[i][j]+all*f[k-1][j-1]%mod)%mod;
                sum[i][j] = ((sum[i][j]+sum[k-1][j-1]*all%mod)%mod+avg*all%mod*f[k-1][j-1]%mod*num%mod)%mod;
            }
        }
        for(int j = 1; j <= cnt; j++){
            f[i][j] = (f[i][j]+f[i][j-1])%mod;
            sum[i][j] = (sum[i][j]+sum[i][j-1])%mod;
        }
    }
    printf("%lld\n",sum[n][cnt]);
    return 0;
}
```

### 基环树dp

洛谷 骑士 题意：相邻的不能同时选

找到环，强制确定环上相邻的两点的状态，使得变成正常的树形dp

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e6 + 5;
int tot, rt;
ll f[maxn][2];
int a[maxn], vis[maxn], fa[maxn];
int ver[maxn], Next[maxn], head[maxn];
template<class T>inline void read(T &res)
{
    char c;T flag=1;
    while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;res=c-'0';
    while((c=getchar())>='0'&&c<='9')res=res*10+c-'0';res*=flag;
}
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
void dfs(int u)
{
    vis[u] = 1;
    f[u][0] = 0; f[u][1] = a[u];
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == rt) continue;
        dfs(v);
        f[u][0] += max(f[v][0],f[v][1]);
        f[u][1] += f[v][0];
    }
}
ll solve(int x)
{
    rt = x;
    vis[rt] = 1;
    while(!vis[fa[rt]]){ rt = fa[rt]; vis[rt] = 1; }
    dfs(rt);
    ll ans = f[rt][0];
    rt = fa[rt];
    dfs(rt);
    ans = max(ans,f[rt][0]);
    return ans;
}

int main()
{
    int n;
    read(n); tot = 1;
    for(int i = 1, x; i <= n; i++){
        read(a[i]); read(x);
        Add(x,i); fa[i] = x;
    }
    ll ans = 0;
    for(int i = 1; i <= n; i++){
        if(vis[i]) continue;
        ans += solve(i);
    }
    printf("%lld\n",ans);
    return 0;
}
```



### 动态dp

线型

cf 750e

在区间[l,r]中删去最少的字符数使得在这个区间内不含有子序列"2016"且含有子序列"2017",如果无法满足条件,输出−1.

动态dp 用线段树维护，每个结点维护一个转移矩阵，ai,j 表示从i状态转移到j状态所需的删除次数，共分5种状态空，2，20，201，2017

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 5;
char s[maxn];
struct Matrix
{
    int a[5][5];
    Matrix(){ memset(a,0x3f,sizeof(a)); }
    Matrix operator * (const Matrix &rhs) const{
        Matrix res;
        for(int i = 0; i < 5; i++){
            for(int j = 0; j < 5; j++){
                for(int k = 0; k < 5; k++){
                    res.a[i][j] = min(res.a[i][j],a[i][k]+rhs.a[k][j]);
                }
            }
        }
        return res;
    }
};
struct node{ int l, r; Matrix mat; } tree[maxn*8];
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r;
    if(l == r){
        for(int i = 0; i < 5; i++) tree[k].mat.a[i][i] = 0;
        if(s[l] == '2') tree[k].mat.a[0][0] = 1, tree[k].mat.a[0][1] = 0;
        if(s[l] == '0') tree[k].mat.a[1][1] = 1, tree[k].mat.a[1][2] = 0;
        if(s[l] == '1') tree[k].mat.a[2][2] = 1, tree[k].mat.a[2][3] = 0;
        if(s[l] == '7') tree[k].mat.a[3][3] = 1, tree[k].mat.a[3][4] = 0;
        if(s[l] == '6') tree[k].mat.a[3][3] = 1, tree[k].mat.a[4][4] = 1;
        return ;
    }
    int mid = (l+r)>>1;
    build(k<<1,l,mid); build(k<<1|1,mid+1,r);
    tree[k].mat = tree[k<<1].mat*tree[k<<1|1].mat;
}
Matrix query(int k,int l,int r)
{
    if(tree[k].l == l && tree[k].r == r){
        return tree[k].mat;
    }
    int mid = (tree[k].l+tree[k].r)>>1;
    if(mid >= r) return query(k<<1,l,r);
    else if(mid < l) return query(k<<1|1,l,r);
    return query(k<<1,l,mid)*query(k<<1|1,mid+1,r);
}
int main()
{
    int n, m, x, y;
    scanf("%d%d%s",&n,&m,s+1);
    build(1,1,n);
    while(m--){
        scanf("%d%d",&x,&y);
        Matrix ans = query(1,x,y);
        printf("%d\n",(ans.a[0][4] == 0x3f3f3f3f ? -1 : ans.a[0][4]));
    }
    return 0;
}
```

树形

洛谷 P4719 【模板】动态 DP

先树剖，再在重链上进行动态dp，参考博客https://www.cnblogs.com/RabbitHu/p/9112811.html

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
const int maxn = 1e5 + 5;
int tot;
int a[maxn];
ll f[maxn][2];
int ver[maxn*2], Next[maxn*2], head[maxn];
int siz[maxn], fa[maxn], dep[maxn], son[maxn];
int seg[maxn], rev[maxn], top[maxn], bot[maxn];
struct Matrix
{
    ll a[2][2];
    Matrix operator * (const Matrix &rhs) const{
        Matrix tmp;
        tmp.a[0][0] = max(a[0][0]+rhs.a[0][0],a[0][1]+rhs.a[1][0]);
        tmp.a[0][1] = max(a[0][0]+rhs.a[0][1],a[0][1]+rhs.a[1][1]);
        tmp.a[1][0] = max(a[1][0]+rhs.a[0][0],a[1][1]+rhs.a[1][0]);
        tmp.a[1][1] = max(a[1][0]+rhs.a[0][1],a[1][1]+rhs.a[1][1]);
        return tmp;
    }
} tp[maxn];
struct node
{
    int l, r;
    Matrix mat;
} tree[maxn*8];
inline int read()
{
    int s = 0, f = 1; char ch = getchar();
    while(ch < '0' || ch > '9'){ if(ch == '-') f = -1; ch = getchar(); }
    while(ch >= '0' && ch <= '9'){ (s *= 10) += ch-'0'; ch = getchar(); }
    return s*f;
}
void Add(int x,int y)
{
    ver[++tot] = y; Next[tot] = head[x]; head[x] = tot;
}
void dfs1(int u,int ff)
{
    fa[u] = ff; dep[u] = dep[ff]+1;
    siz[u] = 1;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff) continue;
        dfs1(v,u);
        siz[u] += siz[v];
        if(siz[v] > siz[son[u]]) son[u] = v;
    }
}
void dfs2(int u,int ff)
{
    if(son[u]){
        seg[son[u]] = ++seg[0];
        top[son[u]] = top[u];
        rev[seg[0]] = son[u];
        dfs2(son[u],u);
        bot[u] = bot[son[u]];
    }
    else bot[u] = u;
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(top[v]) continue;
        seg[v] = ++seg[0];
        top[v] = v;
        rev[seg[0]] = v;
        dfs2(v,u);
    }
}
void dp(int u,int ff)
{
    f[u][1] = a[u];
    for(int i = head[u]; i; i = Next[i]){
        int v = ver[i];
        if(v == ff) continue;
        dp(v,u);
        f[u][0] += max(f[v][0],f[v][1]);
        f[u][1] += f[v][0];
    }
}
void build(int k,int l,int r)
{
    tree[k].l = l; tree[k].r = r;
    if(l == r){
        int u = rev[l], g0 = 0, g1 = a[u];
        for(int i = head[u]; i; i = Next[i]){
            int v = ver[i];
            if(v == fa[u] || v == son[u]) continue;
            g0 += max(f[v][0],f[v][1]);
            g1 += f[v][0];
        }
        tree[k].mat = tp[l] = (Matrix){g0,g0,g1,-inf};
        return ;
    }
    int mid = (l+r)>>1;
    build(k<<1,l,mid); build(k<<1|1,mid+1,r);
    tree[k].mat = tree[k<<1].mat*tree[k<<1|1].mat;
}
Matrix query(int k,int l,int r)
{
    if(tree[k].l == l && tree[k].r == r){
        return tree[k].mat;
    }
    int mid = (tree[k].l+tree[k].r)>>1;
    if(mid >= r) return query(k<<1,l,r);
    else if(mid < l) return query(k<<1|1,l,r);
    return query(k<<1,l,mid)*query(k<<1|1,mid+1,r);
}
void update(int k,int p,int x)
{
    if(tree[k].l == tree[k].r){
        tree[k].mat = tp[p];
        return ;
    }
    int mid = (tree[k].l+tree[k].r)>>1;
    if(mid >= p) update(k<<1,p,x);
    else update(k<<1|1,p,x);
    tree[k].mat = tree[k<<1].mat*tree[k<<1|1].mat;
}
void update(int x,int y)
{
    tp[seg[x]].a[1][0] += y-a[x]; a[x] = y;
    while(x){
        Matrix aa = query(1,seg[top[x]],seg[bot[x]]);
        update(1,seg[x],y);
        Matrix bb = query(1,seg[top[x]],seg[bot[x]]);
        x = fa[top[x]];
        if(!x) break;
        tp[seg[x]].a[0][0] += max(bb.a[0][0],bb.a[1][0])-max(aa.a[0][0],aa.a[1][0]);
        tp[seg[x]].a[0][1] = tp[seg[x]].a[0][0];
        tp[seg[x]].a[1][0] += bb.a[0][0]-aa.a[0][0];
    }
}
int main()
{
    int n, m, x, y;
    n = read(); m = read();
    for(int i = 1; i <= n; i++) a[i] = read();
    for(int i = 1; i < n; i++){
        x = read(); y = read();
        Add(x,y); Add(y,x);
    }
    dfs1(1,0);
    seg[0] = seg[1] = top[1] = rev[1] = 1;
    dfs2(1,0);
    dp(1,0);
    build(1,1,n);
    while(m--){
        x = read(); y = read();
        update(x,y);
        Matrix ans = query(1,seg[1],seg[bot[1]]);
        printf("%lld\n",max(ans.a[0][0],ans.a[1][0]));
    }
    return 0;
}
```

### 斜率优化

P5785 [SDOI2012]任务安排

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 3e5 + 5;
int t[maxn], c[maxn], q[maxn*2];
ll sumt[maxn], sumc[maxn], f[maxn];
int main()
{
    int n, m;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++){
        scanf("%d%d",&t[i],&c[i]);
        sumt[i] = sumt[i-1]+t[i];
        sumc[i] = sumc[i-1]+c[i];
    }
    memset(f,0x3f,sizeof(f));
    f[0] = 0;
    int h = 1, t = 1;
    q[1] = 0;
    for(int i = 1; i <= n; i++){
        int l = h, r = t, mid, p = q[h];
        while(l <= r){
            mid = (l+r)>>1;
            if(f[q[mid+1]]-f[q[mid]] > (m+sumt[i])*(sumc[q[mid+1]]-sumc[q[mid]])) p = q[mid], r = mid-1;
            else l = mid+1;
        }
        f[i] = f[p]-(m+sumt[i])*sumc[p]+m*sumc[n]+sumt[i]*sumc[i];
        while(h < t && (f[q[t]]-f[q[t-1]])*(sumc[i]-sumc[q[t]]) >= (f[i]-f[q[t]])*(sumc[q[t]]-sumc[q[t-1]])) t--;
        q[++t] = i;
    }
    printf("%lld\n",f[n]);
    return 0;
}
```

### 退背包

牛客 回到过去

题意：n个时光胶囊。第i个时光胶囊可以让时光倒流 ai 天。我们将时光倒流天数相同的时光胶囊视为同一种。
小y想恰好回到m天前。而携带过多种类的时光胶囊会浪费太多体力。所以他想知道有哪些种类的时光胶囊是必须携带的。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
int m;
int cnt[maxn], f[maxn];
vector<int> v, ans;
void solve(int x,int num,int flag)
{
    int tmp = 1;
    while(tmp <= num){
        if(flag){
            int val = tmp*x;
            for(int i = m; i >= val; i--) f[i] += f[i-val];
        }
        else{
            int val = tmp*x;
            for(int i = val; i <= m; i++) f[i] -= f[i-val];
        }
        num -= tmp;
        tmp <<= 1;
    }
    if(num){
        int val = num*x;
        if(flag){
            for(int i = m; i >= val; i--) f[i] += f[i-val];
        }
        else{
            for(int i = val; i <= m; i++) f[i] -= f[i-val];
        }
    }
}
int main()
{
    int n;
    scanf("%d%d",&n,&m);
    for(int i = 1; i <= n; i++){
        int x;
        scanf("%d",&x);
        cnt[x]++;
        if(cnt[x] == 1) v.push_back(x);
    }
    f[0] = 1;
    for(int x : v){
        solve(x,cnt[x],1);
    }
    for(int x : v){
        solve(x,cnt[x],0);
        if(!f[m]) ans.push_back(x);
        solve(x,cnt[x],1);
    }
    printf("%d\n",ans.size());
    sort(ans.begin(),ans.end());
    for(int x : ans) printf("%d ",x);
    printf("\n");
    return 0;
}
```

### 分段

环状最大两段子段和

*O*(*n*) 对于答案可能有的所有情况，一种是有一段跨过了端点，另一种是没有跨过端点；所以可以先求一遍两段最大子段和，再对整个序列取反，再求一遍(这时其实就是求出两段的最小子段和，用总和减去后就是跨过端点的两段最大子段和)，这时把两种情况取一个max；



最大m段子段和

*O*(*nm*) 我们发现，求m段子段的过程中，当我已经求出前i个元素，k段的时候，我要做的，其实就是考虑向后多少个元素后再重新开一段。所以该状态为f [j] [0/1]表示前i个元素，j段，第i个元素是否选的最大子段和。转移就好写了：

```c++
f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0])+a[i];
f[i][j][0]=max(f[i-1][j][1],f[i-1][j][0]);
```

## 数论

### **快速幂**

```c++
ll qpow(ll a,ll b, ll k)
{
	ll ret = 1LL;
	while(b){
		if(b & 1LL) ret = (ret*a) % k;
		b >>= 1LL;
		a = a * a % k;
	}
	return ret;
}
```



### gcd

```c++
int gcd(int a,int b){ return b ? gcd(b,a%b) : a; }
```

### exgcd

```c++
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(!b){ x = 1, y = 0; return a; }
    ll d = exgcd(b,a%b,x,y);
    ll z = x; x = y; y = z-y*(a/b);
    return d;
}
```

对于ax+by = c 当c整除gcd(a,b)时，有整数解x，y 通过exgcd计算出的为特殊解x0,y0，转化为一般解为x=c/d*x0+k*b/d, y=c/d*y0 - k*a/d,其中d是gcd(a,b)

求最小整数解时 x = (x%b+b)%b;

### bsgs

给定整数a,b,p 其中a,p 互质，求一个非负整数x，使得a^x = b (mod p)。

bsgs得到的最小非负整数解

```c++
int bsgs(int a,int b,int p)
{
    map<int,int> h; h.clear();
    b %= p;
    int t = (int)sqrt(p*1.0)+1;
    for(int j = 0; j < t; j++){
        int val = (ll)b*qp(a,j,p)%p; //b*a^j
        h[val] = j;
    }
    a = qp(a,t,p); //a^t
    if(a == 0) return b == 0 ? 1 : -1;
    for(int i = 0; i <= t; i++){
        int val = qp(a,i,p); //(a^t)^i
        int j = h.find(val) == h.end() ? -1 : h[val];
        if(j >= 0 && i*t-j >= 0) return i*t-j;
    }
    return -1;
}
```



### 中国剩余定理

模数两两互质

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
ll a[15], b[15], m[15];
ll exgcd(ll a,ll b,ll &x,ll &y)
{
    if(!b){ x = 1, y = 0; return a; }
    ll d = exgcd(b,a%b,x,y);
    ll z = x; x = y; y = z-y*(a/b);
    return d;
}
ll crt()
{
    ll ans = 0, M = 1;
    for(int i = 1; i <= n; i++) M *= a[i];
    for(int i = 1; i <= n; i++){
        m[i] = M/a[i];
        ll x, y;
        exgcd(m[i],a[i],x,y);
        ans = (ans+b[i]*m[i]%M*x%M+M)%M;
    }
    return ans;
}
int main()
{
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%lld%lld",&a[i],&b[i]);
    }
    printf("%lld\n",crt());
    return 0;
}
```

excrt

模数不一定互质

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
int n;
ll a[maxn], b[maxn]; //a为模数 b为余数
ll mul(ll a,ll b,ll mod)
{
    ll res = 0;
    while(b > 0){
        if (b&1) res = (res+a)%mod;
        a = (a+a)%mod;
        b >>= 1;
    }
    return res;
}
ll exgcd(ll a,ll b,ll &x,ll &y) ///ax+by = gcd(a,b);
{
    if(!b){ x = 1, y = 0; return a; }
    ll d = exgcd(b,a%b,x,y);
    ll z = x; x = y; y = z-y*(a/b);
    return d;
}
ll excrt() ///x == b(mod a)
{
    ll m1, r1, m2, r2, x, y, c, t;
    m1 = a[1], r1 = b[1];
    for (int i = 2; i <= n; i++){
        m2 = a[i], r2 = b[i];
        ll d = exgcd(m1,m2,x,y);
        c = (r2-r1%m2+m2)%m2;
        if(c%d) return -1; //-1无解
        t = m2/d;
        x = (mul(x,c/d,t)+t)%t;
        //x = (c/d*x%t+t)%t;
        r1 += x*m1;
        m1 *= t;
        r1 = (r1%m1+m1)%m1;
    }
    return (r1%m1+m1)%m1;
}
int main()
{
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%lld%lld",&a[i],&b[i]);
    }
    printf("%lld\n",excrt());
    return 0;
}
```



### 高斯消元

```c++
#include<bits/stdc++.h>
using namespace std;
double a[20][20], c[20][20], b[20];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i = 1; i <= n+1; i++){
        for(int j = 1; j <= n; j++) scanf("%lf",&a[i][j]);
    }
    // c 系数矩阵 b 常数
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            c[i][j] = 2*(a[i][j]-a[i+1][j]);
            b[i] += a[i][j]*a[i][j]-a[i+1][j]*a[i+1][j];
        }
    }
    // 高斯消元
    for(int i = 1; i <= n; i++){
        // 找到x[i]的系数不为0的一个方程
        for(int j = i; j <= n; j++){
            if(fabs(c[j][i]) > 1e-8){
                for(int k = 1; k <= n; k++) swap(c[i][k],c[j][k]);
                swap(b[i],b[j]);
            }
        }
        // 消去其他方程的x[i]的系数
        for(int j = 1; j <= n; j++){
            if(i == j) continue;
            double rate = c[j][i]/c[i][i];
            for(int k = i; k <= n; k++) c[j][k] -= c[i][k]*rate;
            b[j] -= b[i]*rate;
        }
    }
    for(int i = 1; i < n; i++) printf("%.3f ",b[i]/c[i][i]);
    printf("%.3f\n",b[n]/c[n][n]);
    return 0;
}
```

### 线性空间

有n个整数和m个询问，每个询问给出一个整数k，求从n个数中选出若干个数执行异或运算能够得到的整数集合中（去掉重复的数），第k小的整数是多少。

```c++
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int maxn = 1e4 + 5;
ull a[maxn];
int main()
{
	int t, mycase = 0, n, m;
	scanf("%d",&t);
	while(t--){
        scanf("%d",&n);
        for(int i = 1; i <= n; i++){
            scanf("%llu",&a[i]);
        }
        bool zero = 0;
        int p = n;
        for(int i = 1; i <= n; i++){
            for(int j = i+1; j <= n; j++){
                if(a[j] > a[i]) swap(a[i],a[j]);
            }
            if(!a[i]){ zero = 1; p = i-1; break; }
            for(int k = 63; k >= 0; k--){
                if((a[i]>>k)&1){
                    for(int j = 1; j <= n; j++){
                        if(i != j && ((a[j]>>k)&1)) a[j] ^= a[i];
                    }
                    break;
                }
            }
        }
        scanf("%d",&m);
        printf("Case #%d:\n",++mycase);
        while(m--){
            ull k, ans = 0;
            scanf("%llu",&k);
            if(zero) k--;
            if(k >= 1llu<<p) printf("-1\n");
            else{
                for(int i = p-1; i >= 0; i--){
                    if((k>>i)&1) ans ^= a[p-i];
                }
                printf("%llu\n",ans);
            }
        }
	}
	return 0;
}
```



### 素数筛

```c++
int m;
int prime[maxn], vis[maxn];
void primes(int n)
{
    m = 0;
    for(int i = 2; i <= n; i++){
        if(!vis[i]){ vis[i] = i; prime[++m] = i; }
        for(int j = 1; j <= m; j++){
            if(prime[j] > vis[i] || prime[j] > n/i) break;
            vis[i*prime[j]] = prime[j];
        }
    }
}
```

### 矩阵快速幂

通项f[i+2] = f[i+1]-f[i]

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod = 1e9 + 7;
int f[2], a[2][2] = {{0,-1},{1,1}};
void mul()
{
    int c[2];
    memset(c,0,sizeof(c));
    for(int i = 0; i < 2; i++){
        for(int j = 0; j < 2; j++){
            c[i] = (c[i]+(ll)f[j]*a[j][i]+mod)%mod;
        }
    }
    memcpy(f,c,sizeof(c));
}
void mulself()
{
    int c[2][2];
    memset(c,0,sizeof(c));
    for(int i = 0; i < 2; i++){
        for(int j = 0; j < 2; j++){
            for(int k = 0; k < 2; k++){
                c[i][j] = (c[i][j]+(ll)a[i][k]*a[k][j]+mod)%mod;
            }
        }
    }
    memcpy(a,c,sizeof(c));
}
int main()
{
    int x, y, n;
    scanf("%d%d%d",&x,&y,&n);
    f[0] = (x+mod)%mod;
    f[1] = (y+mod)%mod;
    n--;
    while(n){
        if(n&1) mul();
        mulself();
        n >>= 1;
    }
    printf("%d\n",f[0]);
    return 0;
}
```

### 卡特兰数

**有n个0 n个1 按照某种顺序排成长度为2n的序列，其中任意前缀0的个数都不小于1的个数的序列有 C(2n,n) / (n+1)**

证明：对于序列若不满足条件，则存在最小的位置2p+1 其中有p个0 p+1个1 则在这后面有 n-p个0 和 n-p-1个1 对后面的数取反得到n-p-1个0 和 n-p个1 于是得到一个有n-1个0 和 n+1个1 的排列 反之，有n-1 个0 和 n+1个1 也可以得到一个n个0 和 n个1 的排列（存在前缀0比1多） 得到两者的双射   那么合法的序列就是C(2n,n)-C(2n,n+1)

牛客 小a的学期

 https://ac.nowcoder.com/acm/contest/317/H 

涉及对组合数对非质数取模 质因数分解

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 2e6 + 5;
int mod, cnt;
int prime[maxn], vis[maxn];
int primes(int n)
{
    int m = 0;
    for(int i = 2; i <= n; i++){
        if(!vis[i]){
            vis[i] = i;
            prime[++m] = i;
        }
        for(int j = 1; j <= m; j++){
            if(prime[j] > vis[i] || i*prime[j] > n) break;
            vis[i*prime[j]] = prime[j];
        }
    }
    return m;
}
int doit(int x,int y)
{
    int res = 0;
    while(x){
        res += x/y; x /= y;
    }
    return res;
}
int qp(int x,int y)
{
    int res = 1;
    while(y){
        if(y&1) res = (ll)res*x%mod;
        y >>= 1;
        x = (ll)x*x%mod;
    }
    return res;
}
int C(int n,int m)
{
    int ans = 1;
    for(int i = 1; i <= cnt; i++){
        int x = doit(n,prime[i]);
        int y = doit(n-m,prime[i]);
        int z = doit(m,prime[i]);
        x -= y+z;
        ans = (ll)ans*qp(prime[i],x)%mod;
    }
    return ans;
}
int main()
{
    int n, m;
    scanf("%d%d%d",&n,&m,&mod);
    cnt = primes(2*n);
    printf("%d\n",(C(2*n,n)-C(2*n,n+m)+mod)%mod);
    return 0;
}

```



### 欧拉函数

1到n内与n互质的数的个数称为欧拉函数

```c++
int phi(int n)
{
    int ans = n;
    for(int i = 2; i <= (int)sqrt(n*1.0); i++){
        if(n%i == 0){
            ans = ans/i*(i-1);
            while(n%i == 0) n /= i;
        }
    }
    if(n > 1) ans = ans/n*(n-1);
    return ans;
}
```

欧拉降幂

对于矩阵不成立

若a，n互质，则对于任意正整数b，a的b次方等于a的（ b mod phi(n)）在mod n意义下

推论 a，n不一定互质且b > phi(n) 时，有a的b次方等于 a的( b mod phi(n) +phi(n) ) 在mod n 意义下

## 计算几何

### 凸包

cf1143 f

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
const double eps = 1e-8;
int sta[maxn], used[maxn];
int sgn(double x)
{
    if (fabs(x) < eps) return 0;
    if (x < 0) return -1;
    else return 1;
}
struct Point
{
    double x, y;
    Point(){}
    Point(double _x,double _y){ x = _x, y = _y; }
    bool operator == (const Point &b) const
    {
        return sgn(x-b.x) == 0 && sgn(y-b.y) == 0;
    }
    bool operator < (const Point &b) const
    {
        return sgn(x-b.x) == 0 ? sgn(y-b.y) < 0 : x < b.x;
    }
    Point operator - (const Point &b) const
    {
        return Point(x-b.x, y-b.y);
    }
    double operator * (const Point &b) const
    {
        return x*b.y-y*b.x;
    }
    Point operator + (const Point &b) const
    {
        return Point(x+b.x,y+b.y);
    }
} p[maxn];
bool cmp(Point a,Point b)
{
    return a.x == b.x ? a.y < b.y : a.x < b.x;
}
int solve(int n)
{
    int tp = 0;
    sort(p+1,p+n+1,cmp);
    /*
    sta[++tp] = 1;
    for(int i = 2; i <= n; i++){
        while(tp >= 2 && (p[sta[tp]]-p[sta[tp-1]])*(p[i]-p[sta[tp]]) <= 0) used[sta[tp--]] = 0;
        used[i] = 1; //used表示在凸壳上
        sta[++tp] = i;
    }
    int tmp = tp; //tmp表示下凸壳大小
    for(int i = n-1; i > 0; i--){
        if(used[i]) continue;
        while(tp > tmp && (p[sta[tp]]-p[sta[tp-1]])*(p[i]-p[sta[tp]]) <= 0) used[sta[tp--]] = 0;
        used[i] = 1;
        sta[++tp] = i;
    }
    */
    //只求上凸壳
    sta[++tp] = n;
    for(int i = n-1; i >= 1; i--){
        if(p[i].x == p[i+1].x) continue;
        while(tp >= 2 && (p[sta[tp]]-p[sta[tp-1]])*(p[i]-p[sta[tp]]) <= 0) used[sta[tp--]] = 0;
        used[i] = 1;
        sta[++tp] = i;
    }
    return tp-1;
}
int main()
{
    int n, x, y;
    scanf("%d",&n);
    for(int i = 1; i <= n; i++){
        scanf("%d%d",&x,&y);
        p[i] = Point(x,y-(ll)x*x);
    }
    printf("%d\n",solve(n));
    return 0;
}
```



## 高精度

### 高精度进制转换

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1000;
char str[maxn];
int start[maxn], ans[maxn], res[maxn];
int oldBase, newBase;
int getNum(char c)  //0~9，A~Z,a~z
{
    if(c >= '0' && c <= '9') return c-'0';
    if(c >= 'A' && c <= 'Z') return c-'A'+10;
    return c-'a'+36;
}
char getChar(int i)
{
    if(i >= 0 && i <= 9) return i+'0';
    if(i >= 10 && i <= 35) return i-10+'A';
    return i-36+'a';
}
void change()
{
    start[0] = strlen(str);
    for(int i = 1; i <= start[0]; i++){
        start[i] = getNum(str[i-1]);
    }
}
void solve()
{
    memset(res,0,sizeof(res));
    int y, i, j;
    while(start[0] >= 1){
        y = 0; i = 1;
        ans[0] = start[0];
        while(i <= start[0]){
            y = y*oldBase+start[i];
            ans[i++] = y/newBase;
            y %= newBase;
        }
        res[++res[0]] = y;
        i = 1;
        while(i <= ans[0] && !ans[i]) i++;
        memset(start,0,sizeof(start));
        for(j = i; j <= ans[0]; j++) start[++start[0]] = ans[j];
        memset(ans,0,sizeof(ans));
    }
}
void output()
{
    for(int i = res[0]; i >= 1; i--) printf("%c",getChar(res[i]));
    printf("\n");
}
int main()
{
    int t;
    scanf("%d",&t);
    while(t--){
        scanf("%d%d%s",&oldBase,&newBase,str);
        change();
        solve();
        output();
    }
    return 0;
}
```

## 其它

### 关同步

关同步后cin与scanf不可混用

```c++
ios::sync_with_stdio(false);
cin.tie(false),cout.tie(false);
```

### 读写文件

```c++
freopen("in.txt", "r", stdin);
freopen("out.txt", "w", stdout);
```

### vector去重

```c++
sort(to.begin(),to.end());
to.erase(unique(to.begin(),to.end()),to.end());
```

### 组合数预处理

```c++
void pre(int n)
{
    for(int i = 0; i <= n; i++){
        for(int j = 0; j <= i; j++){
            if(j == 0 || i == j) C[i][j] = 1;
            else C[i][j] = C[i-1][j-1]+C[i-1][j];
        }
    }
}
```



### 优化

```c++
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
#pragma GCC optimize("-fgcse")
#pragma GCC optimize("-fgcse-lm")
#pragma GCC optimize("-fipa-sra")
#pragma GCC optimize("-ftree-pre")
#pragma GCC optimize("-ftree-vrp")
#pragma GCC optimize("-fpeephole2")
#pragma GCC optimize("-ffast-math")
#pragma GCC optimize("-fsched-spec")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("-falign-jumps")
#pragma GCC optimize("-falign-loops")
#pragma GCC optimize("-falign-labels")
#pragma GCC optimize("-fdevirtualize")
#pragma GCC optimize("-fcaller-saves")
#pragma GCC optimize("-fcrossjumping")
#pragma GCC optimize("-fthread-jumps")
#pragma GCC optimize("-funroll-loops")
#pragma GCC optimize("-freorder-blocks")
#pragma GCC optimize("-fschedule-insns")
#pragma GCC optimize("inline-functions")
#pragma GCC optimize("-ftree-tail-merge")
#pragma GCC optimize("-fschedule-insns2")
#pragma GCC optimize("-fstrict-aliasing")
#pragma GCC optimize("-falign-functions")
#pragma GCC optimize("-fcse-follow-jumps")
#pragma GCC optimize("-fsched-interblock")
#pragma GCC optimize("-fpartial-inlining")
#pragma GCC optimize("no-stack-protector")
#pragma GCC optimize("-freorder-functions")
#pragma GCC optimize("-findirect-inlining")
#pragma GCC optimize("-fhoist-adjacent-loads")
#pragma GCC optimize("-frerun-cse-after-loop")
#pragma GCC optimize("inline-small-functions")
#pragma GCC optimize("-finline-small-functions")
#pragma GCC optimize("-ftree-switch-conversion")
#pragma GCC optimize("-foptimize-sibling-calls")
#pragma GCC optimize("-fexpensive-optimizations")
#pragma GCC optimize("inline-functions-called-once")
#pragma GCC optimize("-fdelete-null-pointer-checks")
```

### 三分

求最大

```c++
while(r-l >= eps){
    mid1 = l+(r-l)/3;
    mid2 = r-(r-l)/3;
    if(check(mid1) < check(mid2)) ans = l, l = mid1;
    else r = mid2;
}
```



### 动态差分

 https://ac.nowcoder.com/acm/contest/317/E 

 有2种飞机，一种是只炸上半菱形，一种是炸整个菱形。问所有区域内的所有格子的异或和。 

 ![img](https://img2018.cnblogs.com/blog/1445856/201902/1445856-20190216170525331-1728092707.png) 

 ![img](https://img2018.cnblogs.com/blog/1445856/201902/1445856-20190216170936275-809862675.png) 

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 3005;
const int L = 1000;
int a[maxn][maxn], b[maxn][maxn], c[maxn][maxn], d[maxn][maxn];
void do1(int x,int y,int len)
{
    a[x-len/2][y]++; b[x-len/2][y+1]--;
    a[x+1][y-len/2-1]--; b[x+1][y+len/2+2]++;
}
void do2(int x,int y,int len)
{
    c[x+1][y-len/2+1]++; d[x+1][y+len/2]--;
    c[x+len/2+1][y+1]--; d[x+len/2+1][y]++;
}
int main()
{
    int n, m, q, op, x, y, l;
    scanf("%d%d%d",&n,&m,&q);
    while(q--){
        scanf("%d%d%d%d",&op,&x,&y,&l);
        x += L; y += L;
        do1(x,y,l);
        if(op == 1) do2(x,y,l);
    }
    int ans, res = 0;
    for(int i = 1; i <= n+L*2; i++){
        ans = 0;
        for(int j = 1; j <= m+L*2; j++){
            ans += a[i][j]+b[i][j]+c[i][j]+d[i][j];
            if(i >= L+1 && i <= L+n && j >= L+1 && j <= L+m) res ^= ans;
            a[i+1][j-1] += a[i][j];
            b[i+1][j+1] += b[i][j];
            c[i+1][j+1] += c[i][j];
            d[i+1][j-1] += d[i][j];
        }
    }
    printf("%d\n",res);
    return 0;
}
```

### 获取第k大的元素O(n)

牛客 https://ac.nowcoder.com/acm/contest/327/A

平面上有n个点，问：平面上所有三角形面积第k大的三角形的面积是多少?

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int x[105], y[105];
vector<ll> ans;
int main()
{
    int t, n, m;
    scanf("%d",&t);
    while(t--){
        ans.clear();
        scanf("%d%d",&n,&m);
        for(int i = 1; i <= n; i++){
            scanf("%d%d",&x[i],&y[i]);
        }
        int cnt = 0;
        for(int i = 1; i <= n; i++){
            for(int j = i+1; j <= n; j++){
                for(int k = j+1; k <= n; k++){
                    ll ax = x[j]-x[i], ay = y[j]-y[i];
                    ll bx = x[k]-x[i], by = y[k]-y[i];
                    ans.push_back(abs(ax*by-ay*bx));
                    cnt++;
                }
            }
        }
        // 开头 第几大（从0开始） 结尾
        nth_element(ans.begin(),ans.begin()+cnt-m,ans.end());
        ll tmp = ans[cnt-m];
        if(tmp&1) printf("%lld.50\n",tmp/2);
        else printf("%lld.00\n",tmp/2);
    }
    return 0;
}

```



## 定理

1.Dilworth定理：对于一个偏序集，最少链划分等于最长反链长度。
   Dilworth定理的对偶定理：对于一个偏序集，其最少反链划分数等于其最长链的长度。
   即把一个数列划分成最少的最长不升子序列的数目就等于这个数列的最长上升子序列的长度。

2.以偶数开头的连续四个数异或和为0，对于任意一个数n，n^(n+4)^(n+8)^(n+12) = 0

3.海伦公式 S = sqrt(p*(p-a)*(p-b)(p-c)) p为半周长 即(a+b+c)/2; 若知道三角形的三点坐标,利用向量叉积的方式计算三角形面积 S = sqrt( (ay * bz-az * by)^2 + (az * bx-ax * bz)^2 + (ax * by-ay * bx)^2)/2 若是二维情况，则令az = 0, bz = 0

4.求最大边权最小的生成树就是直接找最小生成树。定理：一棵最小生成树必定是一棵最小瓶颈生成树

5.曼哈顿距离与切比雪夫距离的转换                                                                                                                                             曼哈顿距离是 dis = abs(x1-x2)+abs(y1-y2) 切比雪夫距离是dis = max(abs(x1-x2),abs(y1-y2))                                        1. 将一个点(x,y)的坐标变为(x+y,x−y)后,原坐标系中的曼哈顿距离 = 新坐标系中的切比雪夫距离                                                                  2. 将一个点(x,y)的坐标变为((x+y)/2,(x−y)/2) 后,原坐标系中的切比雪夫距离 = 新坐标系中的曼哈顿距离

或变为（x+y,x-y） 原坐标系中的切比雪夫距离 = 新坐标系中的曼哈顿距离的一半

用处：切比雪夫距离在计算的时候需要取max，往往不是很好优化，对于一个点，计算其他点到该的距离的复杂度为O(n)

而曼哈顿距离只有求和以及取绝对值两种运算，我们把坐标排序后可以去掉绝对值的影响，进而用前缀和优化，可以把复杂度降为O(1)

6. 坐标旋转公式![img](https://private.codecogs.com/gif.latex?%5Cbegin%7Bbmatrix%7D%20x%27%5C%5C%20y%27%20%5Cend%7Bbmatrix%7D%3D%5Cbegin%7Bbmatrix%7D%20cos%5Ctheta%20%26%20sin%5Ctheta%20%5C%5C-sin%5Ctheta%20%26%20cos%5Ctheta%20%5Cend%7Bbmatrix%7D%20%5Cbegin%7Bbmatrix%7D%20x%5C%5C%20y%20%5Cend%7Bbmatrix%7D)  记逆时针旋转方向为正                                                                      x' = x * cos + y * sin , y' = x * (-sin) + y * cos

7. **交换相邻两数**  如果只是交换相邻两数，那么最少交换次数为该序列的逆序数。

   **交换任意两数**

   ```c++
   /*
    *  交换任意两数的本质是改变了元素位置，
    *  故建立元素与其目标状态应放置位置的映射关系
    */
   int getMinSwaps(vector<int> &A)
   {
       //  排序
       vector<int> B(A);
       sort(B.begin(), B.end());
       map<int, int> m;
       int len = (int)A.size();
       for (int i = 0; i < len; i++)
       {
           m[B[i]] = i;    //  建立每个元素与其应放位置的映射关系
       }
   
       int loops = 0;      //  循环节个数
       vector<bool> flag(len, false);
       //  找出循环节的个数
       for (int i = 0; i < len; i++)
       {
           if (!flag[i])
           {
               int j = i;
               while (!flag[j])
               {
                   flag[j] = true;
                   j = m[A[j]];    //  原序列中j位置的元素在有序序列中的位置
               }
               loops++;
           }
       }
       return len - loops;
   }
   
   vector<int> nums;
   
   int main()
   {
       nums.push_back(1);
       nums.push_back(2);
       nums.push_back(4);
       nums.push_back(3);
       nums.push_back(5);
   
       int res = getMinSwaps(nums);
   
       cout << res << '\n';
   
       return 0;
   }
   ```

   **交换任意区间**

   ```c++
   /*
    *  默认目标映射关系是 key 1 => val 1 …… key n => val n
    *  如果序列不是 1~n 可以通过 map 建立新的目标映射关系
    *  交换任意区间的本质是改变了元素的后继，故建立元素与其初始状态后继的映射关系
    */
   const int MAXN = 30;
   
   int n;
   int vis[MAXN];
   int A[MAXN], B[MAXN];
   
   int getMinSwaps()
   {
       memset(vis, 0, sizeof(vis));
   
       for (int i = 1; i <= n; i++)
       {
           B[A[i]] = A[i % n + 1];
       }
       for (int i = 1; i <= n; i++)
       {
           B[i] = (B[i] - 2 + n) % n + 1;
       }
   
       int cnt = n;
       for (int i = 1; i <= n; i++)
       {
           if (vis[i])
           {
               continue;
           }
           vis[i] = 1;
           cnt--;
           for (int j = B[i]; j != i; j = B[j])
           {
               vis[j] = 1;
           }
       }
   
       return cnt;
   }
   
   int main()
   {
       cin >> n;
       for (int i = 1; i <= n; i++)
       {
           cin >> A[i];
       }
   
       int res = getMinSwaps();
   
       cout << res << '\n';
   
       return 0;
   }
   ```


8.在树上有几个关键点，将几个关键点连通的最小子树的边权和是DFS 序求出后，假设关键点按照 DFS 序排序后是 a1, a2, a3, ... , ak，那么所有关键点形成的极小连通子树的边权和的两倍等于dis(a1,a2)+dis(a2,a3)+...+dis(ak-1,ak)+dis(ak,a1)

9.广义 Cayley 定理:

n 个标号节点形成一个有 k 颗树的森林,使得给定的 k 个点没有两个点属于同一颗树的方案数为k*n^(n-k-1)

10.a+b = (a^b) + 2(a & b)